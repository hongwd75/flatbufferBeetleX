// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
#define FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "enumPackets_generated.h"
#include "structs_generated.h"

namespace NetworkMessage {

struct CS_LoginReq;
struct CS_LoginReqBuilder;
struct CS_LoginReq_FBS;

struct CS_WorldJoinReq;
struct CS_WorldJoinReqBuilder;
struct CS_WorldJoinReq_FBS;

struct CS_UpdatePosition;
struct CS_UpdatePositionBuilder;
struct CS_UpdatePosition_FBS;

struct SC_LoginAns;
struct SC_LoginAnsBuilder;
struct SC_LoginAns_FBS;

struct SC_AccountInfo;
struct SC_AccountInfoBuilder;
struct SC_AccountInfo_FBS;

struct SC_WorldEnterNotify;
struct SC_WorldEnterNotifyBuilder;
struct SC_WorldEnterNotify_FBS;

struct SC_CreatePlayer;
struct SC_CreatePlayerBuilder;
struct SC_CreatePlayer_FBS;

struct SC_CreatePlayers;
struct SC_CreatePlayersBuilder;
struct SC_CreatePlayers_FBS;

struct SC_RemovePlayer;
struct SC_RemovePlayerBuilder;
struct SC_RemovePlayer_FBS;

struct SC_UpdatePosition;
struct SC_UpdatePositionBuilder;
struct SC_UpdatePosition_FBS;

struct SC_PlayerUpdate;
struct SC_PlayerUpdateBuilder;
struct SC_PlayerUpdate_FBS;

struct SC_VariousUpdate;
struct SC_VariousUpdateBuilder;
struct SC_VariousUpdate_FBS;

struct SC_RemoveObject;
struct SC_RemoveObjectBuilder;
struct SC_RemoveObject_FBS;

struct SC_PlayerCreate;
struct SC_PlayerCreateBuilder;
struct SC_PlayerCreate_FBS;

struct SC_ModelChange;
struct SC_ModelChangeBuilder;
struct SC_ModelChange_FBS;

struct SC_ObjectCreate;
struct SC_ObjectCreateBuilder;
struct SC_ObjectCreate_FBS;

struct SC_MovingObjectCreate;
struct SC_MovingObjectCreateBuilder;
struct SC_MovingObjectCreate_FBS;

struct SC_NPCCreate;
struct SC_NPCCreateBuilder;
struct SC_NPCCreate_FBS;

struct SC_CharacterStatusUpdate;
struct SC_CharacterStatusUpdateBuilder;
struct SC_CharacterStatusUpdate_FBS;

struct SC_ObjectUpdate;
struct SC_ObjectUpdateBuilder;
struct SC_ObjectUpdate_FBS;

struct SC_CombatAnimation;
struct SC_CombatAnimationBuilder;
struct SC_CombatAnimation_FBS;

struct SC_SpellCastAnimation;
struct SC_SpellCastAnimationBuilder;
struct SC_SpellCastAnimation_FBS;

struct SC_SpellEffectAnimation;
struct SC_SpellEffectAnimationBuilder;
struct SC_SpellEffectAnimation_FBS;

struct SC_EmoteAnimation;
struct SC_EmoteAnimationBuilder;
struct SC_EmoteAnimation_FBS;

struct SC_ConcentrationList;
struct SC_ConcentrationListBuilder;
struct SC_ConcentrationList_FBS;

struct SC_StringMessage;
struct SC_StringMessageBuilder;
struct SC_StringMessage_FBS;

struct SC_DialogBoxMessage;
struct SC_DialogBoxMessageBuilder;
struct SC_DialogBoxMessage_FBS;

struct SC_MaxSpeed;
struct SC_MaxSpeedBuilder;
struct SC_MaxSpeed_FBS;

struct SC_Quit;
struct SC_QuitBuilder;
struct SC_Quit_FBS;

bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator==(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs);
bool operator!=(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs);
bool operator==(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs);
bool operator!=(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs);
bool operator==(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs);
bool operator!=(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs);
bool operator==(const SC_ModelChange_FBS &lhs, const SC_ModelChange_FBS &rhs);
bool operator!=(const SC_ModelChange_FBS &lhs, const SC_ModelChange_FBS &rhs);
bool operator==(const SC_ObjectCreate_FBS &lhs, const SC_ObjectCreate_FBS &rhs);
bool operator!=(const SC_ObjectCreate_FBS &lhs, const SC_ObjectCreate_FBS &rhs);
bool operator==(const SC_MovingObjectCreate_FBS &lhs, const SC_MovingObjectCreate_FBS &rhs);
bool operator!=(const SC_MovingObjectCreate_FBS &lhs, const SC_MovingObjectCreate_FBS &rhs);
bool operator==(const SC_NPCCreate_FBS &lhs, const SC_NPCCreate_FBS &rhs);
bool operator!=(const SC_NPCCreate_FBS &lhs, const SC_NPCCreate_FBS &rhs);
bool operator==(const SC_CharacterStatusUpdate_FBS &lhs, const SC_CharacterStatusUpdate_FBS &rhs);
bool operator!=(const SC_CharacterStatusUpdate_FBS &lhs, const SC_CharacterStatusUpdate_FBS &rhs);
bool operator==(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs);
bool operator!=(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs);
bool operator==(const SC_CombatAnimation_FBS &lhs, const SC_CombatAnimation_FBS &rhs);
bool operator!=(const SC_CombatAnimation_FBS &lhs, const SC_CombatAnimation_FBS &rhs);
bool operator==(const SC_SpellCastAnimation_FBS &lhs, const SC_SpellCastAnimation_FBS &rhs);
bool operator!=(const SC_SpellCastAnimation_FBS &lhs, const SC_SpellCastAnimation_FBS &rhs);
bool operator==(const SC_SpellEffectAnimation_FBS &lhs, const SC_SpellEffectAnimation_FBS &rhs);
bool operator!=(const SC_SpellEffectAnimation_FBS &lhs, const SC_SpellEffectAnimation_FBS &rhs);
bool operator==(const SC_EmoteAnimation_FBS &lhs, const SC_EmoteAnimation_FBS &rhs);
bool operator!=(const SC_EmoteAnimation_FBS &lhs, const SC_EmoteAnimation_FBS &rhs);
bool operator==(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs);
bool operator!=(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs);
bool operator==(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs);
bool operator!=(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs);
bool operator==(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs);
bool operator!=(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs);
bool operator==(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs);
bool operator!=(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs);
bool operator==(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs);
bool operator!=(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs);

struct CS_LoginReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_LoginReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq_FBS";
  }
  std::string id{};
  std::string pwd{};
};

struct CS_LoginReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_LoginReq_FBS NativeTableType;
  typedef CS_LoginReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PWD = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *pwd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PWD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.VerifyString(pwd()) &&
           verifier.EndTable();
  }
  CS_LoginReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_LoginReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_LoginReqBuilder {
  typedef CS_LoginReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CS_LoginReq::VT_ID, id);
  }
  void add_pwd(::flatbuffers::Offset<::flatbuffers::String> pwd) {
    fbb_.AddOffset(CS_LoginReq::VT_PWD, pwd);
  }
  explicit CS_LoginReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_LoginReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_LoginReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pwd = 0) {
  CS_LoginReqBuilder builder_(_fbb);
  builder_.add_pwd(pwd);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReqDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *pwd = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto pwd__ = pwd ? _fbb.CreateString(pwd) : 0;
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      id__,
      pwd__);
}

::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_WorldJoinReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_WorldJoinReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq_FBS";
  }
  int32_t gate = 0;
};

struct CS_WorldJoinReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_WorldJoinReq_FBS NativeTableType;
  typedef CS_WorldJoinReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GATE = 4
  };
  int32_t gate() const {
    return GetField<int32_t>(VT_GATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GATE, 4) &&
           verifier.EndTable();
  }
  CS_WorldJoinReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_WorldJoinReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_WorldJoinReqBuilder {
  typedef CS_WorldJoinReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gate(int32_t gate) {
    fbb_.AddElement<int32_t>(CS_WorldJoinReq::VT_GATE, gate, 0);
  }
  explicit CS_WorldJoinReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_WorldJoinReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_WorldJoinReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gate = 0) {
  CS_WorldJoinReqBuilder builder_(_fbb);
  builder_.add_gate(gate);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef CS_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  CS_UpdatePosition_FBS() = default;
  CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o);
  CS_UpdatePosition_FBS(CS_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  CS_UpdatePosition_FBS &operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct CS_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_UpdatePosition_FBS NativeTableType;
  typedef CS_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  CS_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_UpdatePositionBuilder {
  typedef CS_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(CS_UpdatePosition::VT_POSITION, position);
  }
  explicit CS_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  CS_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_LoginAns_FBS : public ::flatbuffers::NativeTable {
  typedef SC_LoginAns TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns_FBS";
  }
  int32_t errorcode = 0;
  int32_t sessionid = 0;
  std::string nickname{};
};

/////////////////////////////////////////////////////////
struct SC_LoginAns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_LoginAns_FBS NativeTableType;
  typedef SC_LoginAnsBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_SESSIONID = 6,
    VT_NICKNAME = 8
  };
  int32_t errorcode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE, 4) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
  SC_LoginAns_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_LoginAns> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_LoginAnsBuilder {
  typedef SC_LoginAns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(int32_t errorcode) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_ERRORCODE, errorcode, 0);
  }
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_SESSIONID, sessionid, 0);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(SC_LoginAns::VT_NICKNAME, nickname);
  }
  explicit SC_LoginAnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_LoginAns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_LoginAns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  SC_LoginAnsBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_sessionid(sessionid);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAnsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    const char *nickname = nullptr) {
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      errorcode,
      sessionid,
      nickname__);
}

::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_AccountInfo_FBS : public ::flatbuffers::NativeTable {
  typedef SC_AccountInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo_FBS";
  }
  int32_t chartype = 0;
};

struct SC_AccountInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_AccountInfo_FBS NativeTableType;
  typedef SC_AccountInfoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARTYPE = 4
  };
  int32_t chartype() const {
    return GetField<int32_t>(VT_CHARTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARTYPE, 4) &&
           verifier.EndTable();
  }
  SC_AccountInfo_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_AccountInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_AccountInfoBuilder {
  typedef SC_AccountInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chartype(int32_t chartype) {
    fbb_.AddElement<int32_t>(SC_AccountInfo::VT_CHARTYPE, chartype, 0);
  }
  explicit SC_AccountInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_AccountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_AccountInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chartype = 0) {
  SC_AccountInfoBuilder builder_(_fbb);
  builder_.add_chartype(chartype);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_WorldEnterNotify_FBS : public ::flatbuffers::NativeTable {
  typedef SC_WorldEnterNotify TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify_FBS";
  }
  int32_t zoneid = 0;
};

struct SC_WorldEnterNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_WorldEnterNotify_FBS NativeTableType;
  typedef SC_WorldEnterNotifyBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZONEID = 4
  };
  int32_t zoneid() const {
    return GetField<int32_t>(VT_ZONEID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZONEID, 4) &&
           verifier.EndTable();
  }
  SC_WorldEnterNotify_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_WorldEnterNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_WorldEnterNotifyBuilder {
  typedef SC_WorldEnterNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_zoneid(int32_t zoneid) {
    fbb_.AddElement<int32_t>(SC_WorldEnterNotify::VT_ZONEID, zoneid, 0);
  }
  explicit SC_WorldEnterNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_WorldEnterNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_WorldEnterNotify>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t zoneid = 0) {
  SC_WorldEnterNotifyBuilder builder_(_fbb);
  builder_.add_zoneid(zoneid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer_FBS";
  }
  std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> player{};
  SC_CreatePlayer_FBS() = default;
  SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o);
  SC_CreatePlayer_FBS(SC_CreatePlayer_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayer_FBS &operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayer_FBS NativeTableType;
  typedef SC_CreatePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const NetworkMessage::CreatePlayerInfo *player() const {
    return GetPointer<const NetworkMessage::CreatePlayerInfo *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayerBuilder {
  typedef SC_CreatePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player) {
    fbb_.AddOffset(SC_CreatePlayer::VT_PLAYER, player);
  }
  explicit SC_CreatePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player = 0) {
  SC_CreatePlayerBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayers_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayers TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers_FBS";
  }
  std::vector<std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>> player{};
  SC_CreatePlayers_FBS() = default;
  SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o);
  SC_CreatePlayers_FBS(SC_CreatePlayers_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayers_FBS &operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayers_FBS NativeTableType;
  typedef SC_CreatePlayersBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyVector(player()) &&
           verifier.VerifyVectorOfTables(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayers_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayers> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayersBuilder {
  typedef SC_CreatePlayers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player) {
    fbb_.AddOffset(SC_CreatePlayers::VT_PLAYER, player);
  }
  explicit SC_CreatePlayersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player = 0) {
  SC_CreatePlayersBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player = nullptr) {
  auto player__ = player ? _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>(*player) : 0;
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      player__);
}

::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_RemovePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_RemovePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer_FBS";
  }
  int32_t sessionid = 0;
};

struct SC_RemovePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_RemovePlayer_FBS NativeTableType;
  typedef SC_RemovePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           verifier.EndTable();
  }
  SC_RemovePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_RemovePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_RemovePlayerBuilder {
  typedef SC_RemovePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_RemovePlayer::VT_SESSIONID, sessionid, 0);
  }
  explicit SC_RemovePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_RemovePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_RemovePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0) {
  SC_RemovePlayerBuilder builder_(_fbb);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef SC_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  SC_UpdatePosition_FBS() = default;
  SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o);
  SC_UpdatePosition_FBS(SC_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_UpdatePosition_FBS &operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_UpdatePosition_FBS NativeTableType;
  typedef SC_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  SC_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_UpdatePositionBuilder {
  typedef SC_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(SC_UpdatePosition::VT_POSITION, position);
  }
  explicit SC_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  SC_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_PlayerUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_PlayerUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate_FBS";
  }
  int32_t head = 0;
  int32_t health = 0;
  int32_t state = 0;
};

struct SC_PlayerUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_PlayerUpdate_FBS NativeTableType;
  typedef SC_PlayerUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEAD = 4,
    VT_HEALTH = 6,
    VT_STATE = 8
  };
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<int32_t>(verifier, VT_HEALTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
  SC_PlayerUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_PlayerUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_PlayerUpdateBuilder {
  typedef SC_PlayerUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEAD, head, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEALTH, health, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_STATE, state, 0);
  }
  explicit SC_PlayerUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_PlayerUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_PlayerUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t head = 0,
    int32_t health = 0,
    int32_t state = 0) {
  SC_PlayerUpdateBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_health(health);
  builder_.add_head(head);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_VariousUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_VariousUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_VariousUpdate_FBS";
  }
  uint16_t level = 0;
  int32_t maxhealth = 0;
  std::string name{};
  std::string classname{};
  std::string baseclass{};
  std::string lastname{};
  std::string guildname{};
  std::string language{};
};

struct SC_VariousUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_VariousUpdate_FBS NativeTableType;
  typedef SC_VariousUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_VariousUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_MAXHEALTH = 6,
    VT_NAME = 8,
    VT_CLASSNAME = 10,
    VT_BASECLASS = 12,
    VT_LASTNAME = 14,
    VT_GUILDNAME = 16,
    VT_LANGUAGE = 18
  };
  uint16_t level() const {
    return GetField<uint16_t>(VT_LEVEL, 0);
  }
  int32_t maxhealth() const {
    return GetField<int32_t>(VT_MAXHEALTH, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *classname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSNAME);
  }
  const ::flatbuffers::String *baseclass() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BASECLASS);
  }
  const ::flatbuffers::String *lastname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTNAME);
  }
  const ::flatbuffers::String *guildname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUILDNAME);
  }
  const ::flatbuffers::String *language() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LANGUAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_LEVEL, 2) &&
           VerifyField<int32_t>(verifier, VT_MAXHEALTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CLASSNAME) &&
           verifier.VerifyString(classname()) &&
           VerifyOffset(verifier, VT_BASECLASS) &&
           verifier.VerifyString(baseclass()) &&
           VerifyOffset(verifier, VT_LASTNAME) &&
           verifier.VerifyString(lastname()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildname()) &&
           VerifyOffset(verifier, VT_LANGUAGE) &&
           verifier.VerifyString(language()) &&
           verifier.EndTable();
  }
  SC_VariousUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_VariousUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_VariousUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_VariousUpdateBuilder {
  typedef SC_VariousUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(uint16_t level) {
    fbb_.AddElement<uint16_t>(SC_VariousUpdate::VT_LEVEL, level, 0);
  }
  void add_maxhealth(int32_t maxhealth) {
    fbb_.AddElement<int32_t>(SC_VariousUpdate::VT_MAXHEALTH, maxhealth, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_VariousUpdate::VT_NAME, name);
  }
  void add_classname(::flatbuffers::Offset<::flatbuffers::String> classname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_CLASSNAME, classname);
  }
  void add_baseclass(::flatbuffers::Offset<::flatbuffers::String> baseclass) {
    fbb_.AddOffset(SC_VariousUpdate::VT_BASECLASS, baseclass);
  }
  void add_lastname(::flatbuffers::Offset<::flatbuffers::String> lastname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_LASTNAME, lastname);
  }
  void add_guildname(::flatbuffers::Offset<::flatbuffers::String> guildname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_GUILDNAME, guildname);
  }
  void add_language(::flatbuffers::Offset<::flatbuffers::String> language) {
    fbb_.AddOffset(SC_VariousUpdate::VT_LANGUAGE, language);
  }
  explicit SC_VariousUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_VariousUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_VariousUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t level = 0,
    int32_t maxhealth = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> baseclass = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guildname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> language = 0) {
  SC_VariousUpdateBuilder builder_(_fbb);
  builder_.add_language(language);
  builder_.add_guildname(guildname);
  builder_.add_lastname(lastname);
  builder_.add_baseclass(baseclass);
  builder_.add_classname(classname);
  builder_.add_name(name);
  builder_.add_maxhealth(maxhealth);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t level = 0,
    int32_t maxhealth = 0,
    const char *name = nullptr,
    const char *classname = nullptr,
    const char *baseclass = nullptr,
    const char *lastname = nullptr,
    const char *guildname = nullptr,
    const char *language = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto classname__ = classname ? _fbb.CreateString(classname) : 0;
  auto baseclass__ = baseclass ? _fbb.CreateString(baseclass) : 0;
  auto lastname__ = lastname ? _fbb.CreateString(lastname) : 0;
  auto guildname__ = guildname ? _fbb.CreateString(guildname) : 0;
  auto language__ = language ? _fbb.CreateString(language) : 0;
  return NetworkMessage::CreateSC_VariousUpdate(
      _fbb,
      level,
      maxhealth,
      name__,
      classname__,
      baseclass__,
      lastname__,
      guildname__,
      language__);
}

::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_RemoveObject_FBS : public ::flatbuffers::NativeTable {
  typedef SC_RemoveObject TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemoveObject_FBS";
  }
  uint16_t objectid = 0;
  uint16_t type = 0;
};

struct SC_RemoveObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_RemoveObject_FBS NativeTableType;
  typedef SC_RemoveObjectBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemoveObject";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_TYPE = 6
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t type() const {
    return GetField<uint16_t>(VT_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_TYPE, 2) &&
           verifier.EndTable();
  }
  SC_RemoveObject_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_RemoveObject_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_RemoveObject> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_RemoveObjectBuilder {
  typedef SC_RemoveObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_RemoveObject::VT_OBJECTID, objectid, 0);
  }
  void add_type(uint16_t type) {
    fbb_.AddElement<uint16_t>(SC_RemoveObject::VT_TYPE, type, 0);
  }
  explicit SC_RemoveObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_RemoveObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_RemoveObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t type = 0) {
  SC_RemoveObjectBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_PlayerCreate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_PlayerCreate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerCreate_FBS";
  }
  std::shared_ptr<NetworkMessage::Vector3Int> position{};
  int32_t sessionid = 0;
  uint16_t objectid = 0;
  uint16_t heading = 0;
  uint16_t model = 0;
  uint8_t level = 0;
  uint8_t flags = 0;
  std::string name{};
  std::string guildname{};
  std::string lastname{};
  SC_PlayerCreate_FBS() = default;
  SC_PlayerCreate_FBS(const SC_PlayerCreate_FBS &o);
  SC_PlayerCreate_FBS(SC_PlayerCreate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_PlayerCreate_FBS &operator=(SC_PlayerCreate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_PlayerCreate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_PlayerCreate_FBS NativeTableType;
  typedef SC_PlayerCreateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerCreate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_SESSIONID = 6,
    VT_OBJECTID = 8,
    VT_HEADING = 10,
    VT_MODEL = 12,
    VT_LEVEL = 14,
    VT_FLAGS = 16,
    VT_NAME = 18,
    VT_GUILDNAME = 20,
    VT_LASTNAME = 22
  };
  const NetworkMessage::Vector3Int *position() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_POSITION);
  }
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *guildname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUILDNAME);
  }
  const ::flatbuffers::String *lastname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_POSITION, 4) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildname()) &&
           VerifyOffset(verifier, VT_LASTNAME) &&
           verifier.VerifyString(lastname()) &&
           verifier.EndTable();
  }
  SC_PlayerCreate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_PlayerCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_PlayerCreate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_PlayerCreateBuilder {
  typedef SC_PlayerCreate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const NetworkMessage::Vector3Int *position) {
    fbb_.AddStruct(SC_PlayerCreate::VT_POSITION, position);
  }
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_PlayerCreate::VT_SESSIONID, sessionid, 0);
  }
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_OBJECTID, objectid, 0);
  }
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_HEADING, heading, 0);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_MODEL, model, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(SC_PlayerCreate::VT_LEVEL, level, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(SC_PlayerCreate::VT_FLAGS, flags, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_PlayerCreate::VT_NAME, name);
  }
  void add_guildname(::flatbuffers::Offset<::flatbuffers::String> guildname) {
    fbb_.AddOffset(SC_PlayerCreate::VT_GUILDNAME, guildname);
  }
  void add_lastname(::flatbuffers::Offset<::flatbuffers::String> lastname) {
    fbb_.AddOffset(SC_PlayerCreate::VT_LASTNAME, lastname);
  }
  explicit SC_PlayerCreateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_PlayerCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_PlayerCreate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t sessionid = 0,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t model = 0,
    uint8_t level = 0,
    uint8_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guildname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastname = 0) {
  SC_PlayerCreateBuilder builder_(_fbb);
  builder_.add_lastname(lastname);
  builder_.add_guildname(guildname);
  builder_.add_name(name);
  builder_.add_sessionid(sessionid);
  builder_.add_position(position);
  builder_.add_model(model);
  builder_.add_heading(heading);
  builder_.add_objectid(objectid);
  builder_.add_flags(flags);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t sessionid = 0,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t model = 0,
    uint8_t level = 0,
    uint8_t flags = 0,
    const char *name = nullptr,
    const char *guildname = nullptr,
    const char *lastname = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto guildname__ = guildname ? _fbb.CreateString(guildname) : 0;
  auto lastname__ = lastname ? _fbb.CreateString(lastname) : 0;
  return NetworkMessage::CreateSC_PlayerCreate(
      _fbb,
      position,
      sessionid,
      objectid,
      heading,
      model,
      level,
      flags,
      name__,
      guildname__,
      lastname__);
}

::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ModelChange_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ModelChange TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ModelChange_FBS";
  }
  uint16_t objectid = 0;
  uint16_t model = 0;
  int32_t newsize = 0;
};

struct SC_ModelChange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ModelChange_FBS NativeTableType;
  typedef SC_ModelChangeBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ModelChange";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_MODEL = 6,
    VT_NEWSIZE = 8
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  int32_t newsize() const {
    return GetField<int32_t>(VT_NEWSIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<int32_t>(verifier, VT_NEWSIZE, 4) &&
           verifier.EndTable();
  }
  SC_ModelChange_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ModelChange_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ModelChange> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ModelChange_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ModelChangeBuilder {
  typedef SC_ModelChange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_ModelChange::VT_OBJECTID, objectid, 0);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_ModelChange::VT_MODEL, model, 0);
  }
  void add_newsize(int32_t newsize) {
    fbb_.AddElement<int32_t>(SC_ModelChange::VT_NEWSIZE, newsize, 0);
  }
  explicit SC_ModelChangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ModelChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ModelChange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ModelChange> CreateSC_ModelChange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t model = 0,
    int32_t newsize = 0) {
  SC_ModelChangeBuilder builder_(_fbb);
  builder_.add_newsize(newsize);
  builder_.add_model(model);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_ModelChange> CreateSC_ModelChange(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ModelChange_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ObjectCreate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ObjectCreate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectCreate_FBS";
  }
  uint16_t objectid = 0;
  uint16_t heading = 0;
  uint16_t emblem = 0;
  uint16_t model = 0;
  std::shared_ptr<NetworkMessage::Vector3Int> position{};
  int32_t flags = 0;
  std::string name{};
  SC_ObjectCreate_FBS() = default;
  SC_ObjectCreate_FBS(const SC_ObjectCreate_FBS &o);
  SC_ObjectCreate_FBS(SC_ObjectCreate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_ObjectCreate_FBS &operator=(SC_ObjectCreate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_ObjectCreate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ObjectCreate_FBS NativeTableType;
  typedef SC_ObjectCreateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectCreate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_HEADING = 6,
    VT_EMBLEM = 8,
    VT_MODEL = 10,
    VT_POSITION = 12,
    VT_FLAGS = 14,
    VT_NAME = 16
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  uint16_t emblem() const {
    return GetField<uint16_t>(VT_EMBLEM, 0);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  const NetworkMessage::Vector3Int *position() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_POSITION);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<uint16_t>(verifier, VT_EMBLEM, 2) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_POSITION, 4) &&
           VerifyField<int32_t>(verifier, VT_FLAGS, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  SC_ObjectCreate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ObjectCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ObjectCreate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ObjectCreateBuilder {
  typedef SC_ObjectCreate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_ObjectCreate::VT_OBJECTID, objectid, 0);
  }
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_ObjectCreate::VT_HEADING, heading, 0);
  }
  void add_emblem(uint16_t emblem) {
    fbb_.AddElement<uint16_t>(SC_ObjectCreate::VT_EMBLEM, emblem, 0);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_ObjectCreate::VT_MODEL, model, 0);
  }
  void add_position(const NetworkMessage::Vector3Int *position) {
    fbb_.AddStruct(SC_ObjectCreate::VT_POSITION, position);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(SC_ObjectCreate::VT_FLAGS, flags, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_ObjectCreate::VT_NAME, name);
  }
  explicit SC_ObjectCreateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ObjectCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ObjectCreate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ObjectCreate> CreateSC_ObjectCreate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t emblem = 0,
    uint16_t model = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  SC_ObjectCreateBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_flags(flags);
  builder_.add_position(position);
  builder_.add_model(model);
  builder_.add_emblem(emblem);
  builder_.add_heading(heading);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_ObjectCreate> CreateSC_ObjectCreateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t emblem = 0,
    uint16_t model = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t flags = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return NetworkMessage::CreateSC_ObjectCreate(
      _fbb,
      objectid,
      heading,
      emblem,
      model,
      position,
      flags,
      name__);
}

::flatbuffers::Offset<SC_ObjectCreate> CreateSC_ObjectCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_MovingObjectCreate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_MovingObjectCreate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MovingObjectCreate_FBS";
  }
  uint16_t objectid = 0;
  uint16_t heading = 0;
  std::shared_ptr<NetworkMessage::Vector3Int> position{};
  uint16_t model = 0;
  int32_t flags = 0;
  uint16_t emblem = 0;
  std::string name{};
  SC_MovingObjectCreate_FBS() = default;
  SC_MovingObjectCreate_FBS(const SC_MovingObjectCreate_FBS &o);
  SC_MovingObjectCreate_FBS(SC_MovingObjectCreate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_MovingObjectCreate_FBS &operator=(SC_MovingObjectCreate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_MovingObjectCreate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_MovingObjectCreate_FBS NativeTableType;
  typedef SC_MovingObjectCreateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MovingObjectCreate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_HEADING = 6,
    VT_POSITION = 8,
    VT_MODEL = 10,
    VT_FLAGS = 12,
    VT_EMBLEM = 14,
    VT_NAME = 16
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  const NetworkMessage::Vector3Int *position() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_POSITION);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  uint16_t emblem() const {
    return GetField<uint16_t>(VT_EMBLEM, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_POSITION, 4) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<int32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint16_t>(verifier, VT_EMBLEM, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  SC_MovingObjectCreate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_MovingObjectCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_MovingObjectCreate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MovingObjectCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_MovingObjectCreateBuilder {
  typedef SC_MovingObjectCreate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_MovingObjectCreate::VT_OBJECTID, objectid, 0);
  }
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_MovingObjectCreate::VT_HEADING, heading, 0);
  }
  void add_position(const NetworkMessage::Vector3Int *position) {
    fbb_.AddStruct(SC_MovingObjectCreate::VT_POSITION, position);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_MovingObjectCreate::VT_MODEL, model, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(SC_MovingObjectCreate::VT_FLAGS, flags, 0);
  }
  void add_emblem(uint16_t emblem) {
    fbb_.AddElement<uint16_t>(SC_MovingObjectCreate::VT_EMBLEM, emblem, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_MovingObjectCreate::VT_NAME, name);
  }
  explicit SC_MovingObjectCreateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_MovingObjectCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_MovingObjectCreate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_MovingObjectCreate> CreateSC_MovingObjectCreate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    uint16_t model = 0,
    int32_t flags = 0,
    uint16_t emblem = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  SC_MovingObjectCreateBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_flags(flags);
  builder_.add_position(position);
  builder_.add_emblem(emblem);
  builder_.add_model(model);
  builder_.add_heading(heading);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_MovingObjectCreate> CreateSC_MovingObjectCreateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    uint16_t model = 0,
    int32_t flags = 0,
    uint16_t emblem = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return NetworkMessage::CreateSC_MovingObjectCreate(
      _fbb,
      objectid,
      heading,
      position,
      model,
      flags,
      emblem,
      name__);
}

::flatbuffers::Offset<SC_MovingObjectCreate> CreateSC_MovingObjectCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MovingObjectCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_NPCCreate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_NPCCreate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_NPCCreate_FBS";
  }
  uint16_t objectid = 0;
  uint16_t heading = 0;
  std::shared_ptr<NetworkMessage::Vector3Int> position{};
  uint16_t speed = 0;
  uint16_t speedz = 0;
  uint16_t model = 0;
  uint8_t size = 0;
  uint8_t level = 0;
  uint8_t flags = 0;
  uint8_t flags2 = 0;
  uint8_t flags3 = 0;
  std::string name{};
  std::string guildname{};
  SC_NPCCreate_FBS() = default;
  SC_NPCCreate_FBS(const SC_NPCCreate_FBS &o);
  SC_NPCCreate_FBS(SC_NPCCreate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_NPCCreate_FBS &operator=(SC_NPCCreate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_NPCCreate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_NPCCreate_FBS NativeTableType;
  typedef SC_NPCCreateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_NPCCreate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_HEADING = 6,
    VT_POSITION = 8,
    VT_SPEED = 10,
    VT_SPEEDZ = 12,
    VT_MODEL = 14,
    VT_SIZE = 16,
    VT_LEVEL = 18,
    VT_FLAGS = 20,
    VT_FLAGS2 = 22,
    VT_FLAGS3 = 24,
    VT_NAME = 26,
    VT_GUILDNAME = 28
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  const NetworkMessage::Vector3Int *position() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_POSITION);
  }
  uint16_t speed() const {
    return GetField<uint16_t>(VT_SPEED, 0);
  }
  uint16_t speedz() const {
    return GetField<uint16_t>(VT_SPEEDZ, 0);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  uint8_t size() const {
    return GetField<uint8_t>(VT_SIZE, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  uint8_t flags2() const {
    return GetField<uint8_t>(VT_FLAGS2, 0);
  }
  uint8_t flags3() const {
    return GetField<uint8_t>(VT_FLAGS3, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *guildname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUILDNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_POSITION, 4) &&
           VerifyField<uint16_t>(verifier, VT_SPEED, 2) &&
           VerifyField<uint16_t>(verifier, VT_SPEEDZ, 2) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<uint8_t>(verifier, VT_SIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS2, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS3, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildname()) &&
           verifier.EndTable();
  }
  SC_NPCCreate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_NPCCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_NPCCreate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_NPCCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_NPCCreateBuilder {
  typedef SC_NPCCreate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_NPCCreate::VT_OBJECTID, objectid, 0);
  }
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_NPCCreate::VT_HEADING, heading, 0);
  }
  void add_position(const NetworkMessage::Vector3Int *position) {
    fbb_.AddStruct(SC_NPCCreate::VT_POSITION, position);
  }
  void add_speed(uint16_t speed) {
    fbb_.AddElement<uint16_t>(SC_NPCCreate::VT_SPEED, speed, 0);
  }
  void add_speedz(uint16_t speedz) {
    fbb_.AddElement<uint16_t>(SC_NPCCreate::VT_SPEEDZ, speedz, 0);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_NPCCreate::VT_MODEL, model, 0);
  }
  void add_size(uint8_t size) {
    fbb_.AddElement<uint8_t>(SC_NPCCreate::VT_SIZE, size, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(SC_NPCCreate::VT_LEVEL, level, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(SC_NPCCreate::VT_FLAGS, flags, 0);
  }
  void add_flags2(uint8_t flags2) {
    fbb_.AddElement<uint8_t>(SC_NPCCreate::VT_FLAGS2, flags2, 0);
  }
  void add_flags3(uint8_t flags3) {
    fbb_.AddElement<uint8_t>(SC_NPCCreate::VT_FLAGS3, flags3, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_NPCCreate::VT_NAME, name);
  }
  void add_guildname(::flatbuffers::Offset<::flatbuffers::String> guildname) {
    fbb_.AddOffset(SC_NPCCreate::VT_GUILDNAME, guildname);
  }
  explicit SC_NPCCreateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_NPCCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_NPCCreate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_NPCCreate> CreateSC_NPCCreate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    uint16_t speed = 0,
    uint16_t speedz = 0,
    uint16_t model = 0,
    uint8_t size = 0,
    uint8_t level = 0,
    uint8_t flags = 0,
    uint8_t flags2 = 0,
    uint8_t flags3 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guildname = 0) {
  SC_NPCCreateBuilder builder_(_fbb);
  builder_.add_guildname(guildname);
  builder_.add_name(name);
  builder_.add_position(position);
  builder_.add_model(model);
  builder_.add_speedz(speedz);
  builder_.add_speed(speed);
  builder_.add_heading(heading);
  builder_.add_objectid(objectid);
  builder_.add_flags3(flags3);
  builder_.add_flags2(flags2);
  builder_.add_flags(flags);
  builder_.add_level(level);
  builder_.add_size(size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_NPCCreate> CreateSC_NPCCreateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *position = nullptr,
    uint16_t speed = 0,
    uint16_t speedz = 0,
    uint16_t model = 0,
    uint8_t size = 0,
    uint8_t level = 0,
    uint8_t flags = 0,
    uint8_t flags2 = 0,
    uint8_t flags3 = 0,
    const char *name = nullptr,
    const char *guildname = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto guildname__ = guildname ? _fbb.CreateString(guildname) : 0;
  return NetworkMessage::CreateSC_NPCCreate(
      _fbb,
      objectid,
      heading,
      position,
      speed,
      speedz,
      model,
      size,
      level,
      flags,
      flags2,
      flags3,
      name__,
      guildname__);
}

::flatbuffers::Offset<SC_NPCCreate> CreateSC_NPCCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_NPCCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CharacterStatusUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CharacterStatusUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CharacterStatusUpdate_FBS";
  }
  bool sittingflag = false;
  uint8_t healthpercent = 0;
  uint8_t manapercent = 0;
  uint8_t endurancepercent = 0;
  uint8_t conpercent = 0;
  int32_t maxmana = 0;
  int32_t maxendurance = 0;
  int32_t maxconcetration = 0;
  int32_t maxhealth = 0;
  int32_t endurance = 0;
  int32_t mana = 0;
  int32_t concentration = 0;
  int32_t health = 0;
};

struct SC_CharacterStatusUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CharacterStatusUpdate_FBS NativeTableType;
  typedef SC_CharacterStatusUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CharacterStatusUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITTINGFLAG = 4,
    VT_HEALTHPERCENT = 6,
    VT_MANAPERCENT = 8,
    VT_ENDURANCEPERCENT = 10,
    VT_CONPERCENT = 12,
    VT_MAXMANA = 14,
    VT_MAXENDURANCE = 16,
    VT_MAXCONCETRATION = 18,
    VT_MAXHEALTH = 20,
    VT_ENDURANCE = 22,
    VT_MANA = 24,
    VT_CONCENTRATION = 26,
    VT_HEALTH = 28
  };
  bool sittingflag() const {
    return GetField<uint8_t>(VT_SITTINGFLAG, 0) != 0;
  }
  uint8_t healthpercent() const {
    return GetField<uint8_t>(VT_HEALTHPERCENT, 0);
  }
  uint8_t manapercent() const {
    return GetField<uint8_t>(VT_MANAPERCENT, 0);
  }
  uint8_t endurancepercent() const {
    return GetField<uint8_t>(VT_ENDURANCEPERCENT, 0);
  }
  uint8_t conpercent() const {
    return GetField<uint8_t>(VT_CONPERCENT, 0);
  }
  int32_t maxmana() const {
    return GetField<int32_t>(VT_MAXMANA, 0);
  }
  int32_t maxendurance() const {
    return GetField<int32_t>(VT_MAXENDURANCE, 0);
  }
  int32_t maxconcetration() const {
    return GetField<int32_t>(VT_MAXCONCETRATION, 0);
  }
  int32_t maxhealth() const {
    return GetField<int32_t>(VT_MAXHEALTH, 0);
  }
  int32_t endurance() const {
    return GetField<int32_t>(VT_ENDURANCE, 0);
  }
  int32_t mana() const {
    return GetField<int32_t>(VT_MANA, 0);
  }
  int32_t concentration() const {
    return GetField<int32_t>(VT_CONCENTRATION, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SITTINGFLAG, 1) &&
           VerifyField<uint8_t>(verifier, VT_HEALTHPERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MANAPERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENDURANCEPERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_CONPERCENT, 1) &&
           VerifyField<int32_t>(verifier, VT_MAXMANA, 4) &&
           VerifyField<int32_t>(verifier, VT_MAXENDURANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAXCONCETRATION, 4) &&
           VerifyField<int32_t>(verifier, VT_MAXHEALTH, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDURANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_MANA, 4) &&
           VerifyField<int32_t>(verifier, VT_CONCENTRATION, 4) &&
           VerifyField<int32_t>(verifier, VT_HEALTH, 4) &&
           verifier.EndTable();
  }
  SC_CharacterStatusUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CharacterStatusUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CharacterStatusUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CharacterStatusUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CharacterStatusUpdateBuilder {
  typedef SC_CharacterStatusUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sittingflag(bool sittingflag) {
    fbb_.AddElement<uint8_t>(SC_CharacterStatusUpdate::VT_SITTINGFLAG, static_cast<uint8_t>(sittingflag), 0);
  }
  void add_healthpercent(uint8_t healthpercent) {
    fbb_.AddElement<uint8_t>(SC_CharacterStatusUpdate::VT_HEALTHPERCENT, healthpercent, 0);
  }
  void add_manapercent(uint8_t manapercent) {
    fbb_.AddElement<uint8_t>(SC_CharacterStatusUpdate::VT_MANAPERCENT, manapercent, 0);
  }
  void add_endurancepercent(uint8_t endurancepercent) {
    fbb_.AddElement<uint8_t>(SC_CharacterStatusUpdate::VT_ENDURANCEPERCENT, endurancepercent, 0);
  }
  void add_conpercent(uint8_t conpercent) {
    fbb_.AddElement<uint8_t>(SC_CharacterStatusUpdate::VT_CONPERCENT, conpercent, 0);
  }
  void add_maxmana(int32_t maxmana) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_MAXMANA, maxmana, 0);
  }
  void add_maxendurance(int32_t maxendurance) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_MAXENDURANCE, maxendurance, 0);
  }
  void add_maxconcetration(int32_t maxconcetration) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_MAXCONCETRATION, maxconcetration, 0);
  }
  void add_maxhealth(int32_t maxhealth) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_MAXHEALTH, maxhealth, 0);
  }
  void add_endurance(int32_t endurance) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_ENDURANCE, endurance, 0);
  }
  void add_mana(int32_t mana) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_MANA, mana, 0);
  }
  void add_concentration(int32_t concentration) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_CONCENTRATION, concentration, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(SC_CharacterStatusUpdate::VT_HEALTH, health, 0);
  }
  explicit SC_CharacterStatusUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CharacterStatusUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CharacterStatusUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CharacterStatusUpdate> CreateSC_CharacterStatusUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool sittingflag = false,
    uint8_t healthpercent = 0,
    uint8_t manapercent = 0,
    uint8_t endurancepercent = 0,
    uint8_t conpercent = 0,
    int32_t maxmana = 0,
    int32_t maxendurance = 0,
    int32_t maxconcetration = 0,
    int32_t maxhealth = 0,
    int32_t endurance = 0,
    int32_t mana = 0,
    int32_t concentration = 0,
    int32_t health = 0) {
  SC_CharacterStatusUpdateBuilder builder_(_fbb);
  builder_.add_health(health);
  builder_.add_concentration(concentration);
  builder_.add_mana(mana);
  builder_.add_endurance(endurance);
  builder_.add_maxhealth(maxhealth);
  builder_.add_maxconcetration(maxconcetration);
  builder_.add_maxendurance(maxendurance);
  builder_.add_maxmana(maxmana);
  builder_.add_conpercent(conpercent);
  builder_.add_endurancepercent(endurancepercent);
  builder_.add_manapercent(manapercent);
  builder_.add_healthpercent(healthpercent);
  builder_.add_sittingflag(sittingflag);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_CharacterStatusUpdate> CreateSC_CharacterStatusUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CharacterStatusUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ObjectUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ObjectUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectUpdate_FBS";
  }
  uint16_t heading = 0;
  std::shared_ptr<NetworkMessage::Vector3Int> currentzonepos{};
  std::shared_ptr<NetworkMessage::Vector3Int> targetzonepos{};
  uint16_t myobjectid = 0;
  uint16_t targetobjectid = 0;
  uint8_t healthpercent = 0;
  uint8_t flags = 0;
  uint8_t zoneskinid = 0;
  uint8_t targetzone = 0;
  SC_ObjectUpdate_FBS() = default;
  SC_ObjectUpdate_FBS(const SC_ObjectUpdate_FBS &o);
  SC_ObjectUpdate_FBS(SC_ObjectUpdate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_ObjectUpdate_FBS &operator=(SC_ObjectUpdate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_ObjectUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ObjectUpdate_FBS NativeTableType;
  typedef SC_ObjectUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADING = 4,
    VT_CURRENTZONEPOS = 6,
    VT_TARGETZONEPOS = 8,
    VT_MYOBJECTID = 10,
    VT_TARGETOBJECTID = 12,
    VT_HEALTHPERCENT = 14,
    VT_FLAGS = 16,
    VT_ZONESKINID = 18,
    VT_TARGETZONE = 20
  };
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  const NetworkMessage::Vector3Int *currentzonepos() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_CURRENTZONEPOS);
  }
  const NetworkMessage::Vector3Int *targetzonepos() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_TARGETZONEPOS);
  }
  uint16_t myobjectid() const {
    return GetField<uint16_t>(VT_MYOBJECTID, 0);
  }
  uint16_t targetobjectid() const {
    return GetField<uint16_t>(VT_TARGETOBJECTID, 0);
  }
  uint8_t healthpercent() const {
    return GetField<uint8_t>(VT_HEALTHPERCENT, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  uint8_t zoneskinid() const {
    return GetField<uint8_t>(VT_ZONESKINID, 0);
  }
  uint8_t targetzone() const {
    return GetField<uint8_t>(VT_TARGETZONE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_CURRENTZONEPOS, 4) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_TARGETZONEPOS, 4) &&
           VerifyField<uint16_t>(verifier, VT_MYOBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_TARGETOBJECTID, 2) &&
           VerifyField<uint8_t>(verifier, VT_HEALTHPERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZONESKINID, 1) &&
           VerifyField<uint8_t>(verifier, VT_TARGETZONE, 1) &&
           verifier.EndTable();
  }
  SC_ObjectUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ObjectUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ObjectUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ObjectUpdateBuilder {
  typedef SC_ObjectUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_HEADING, heading, 0);
  }
  void add_currentzonepos(const NetworkMessage::Vector3Int *currentzonepos) {
    fbb_.AddStruct(SC_ObjectUpdate::VT_CURRENTZONEPOS, currentzonepos);
  }
  void add_targetzonepos(const NetworkMessage::Vector3Int *targetzonepos) {
    fbb_.AddStruct(SC_ObjectUpdate::VT_TARGETZONEPOS, targetzonepos);
  }
  void add_myobjectid(uint16_t myobjectid) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_MYOBJECTID, myobjectid, 0);
  }
  void add_targetobjectid(uint16_t targetobjectid) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_TARGETOBJECTID, targetobjectid, 0);
  }
  void add_healthpercent(uint8_t healthpercent) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_HEALTHPERCENT, healthpercent, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_FLAGS, flags, 0);
  }
  void add_zoneskinid(uint8_t zoneskinid) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_ZONESKINID, zoneskinid, 0);
  }
  void add_targetzone(uint8_t targetzone) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_TARGETZONE, targetzone, 0);
  }
  explicit SC_ObjectUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ObjectUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ObjectUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *currentzonepos = nullptr,
    const NetworkMessage::Vector3Int *targetzonepos = nullptr,
    uint16_t myobjectid = 0,
    uint16_t targetobjectid = 0,
    uint8_t healthpercent = 0,
    uint8_t flags = 0,
    uint8_t zoneskinid = 0,
    uint8_t targetzone = 0) {
  SC_ObjectUpdateBuilder builder_(_fbb);
  builder_.add_targetzonepos(targetzonepos);
  builder_.add_currentzonepos(currentzonepos);
  builder_.add_targetobjectid(targetobjectid);
  builder_.add_myobjectid(myobjectid);
  builder_.add_heading(heading);
  builder_.add_targetzone(targetzone);
  builder_.add_zoneskinid(zoneskinid);
  builder_.add_flags(flags);
  builder_.add_healthpercent(healthpercent);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CombatAnimation_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CombatAnimation TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CombatAnimation_FBS";
  }
  uint16_t attackobjectid = 0;
  uint16_t defenderobjectid = 0;
  uint16_t weaponid = 0;
  uint16_t shieldid = 0;
  uint16_t style = 0;
  uint8_t stance = 0;
  uint8_t result = 0;
  uint8_t healthpercent = 0;
};

struct SC_CombatAnimation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CombatAnimation_FBS NativeTableType;
  typedef SC_CombatAnimationBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CombatAnimation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTACKOBJECTID = 4,
    VT_DEFENDEROBJECTID = 6,
    VT_WEAPONID = 8,
    VT_SHIELDID = 10,
    VT_STYLE = 12,
    VT_STANCE = 14,
    VT_RESULT = 16,
    VT_HEALTHPERCENT = 18
  };
  uint16_t attackobjectid() const {
    return GetField<uint16_t>(VT_ATTACKOBJECTID, 0);
  }
  uint16_t defenderobjectid() const {
    return GetField<uint16_t>(VT_DEFENDEROBJECTID, 0);
  }
  uint16_t weaponid() const {
    return GetField<uint16_t>(VT_WEAPONID, 0);
  }
  uint16_t shieldid() const {
    return GetField<uint16_t>(VT_SHIELDID, 0);
  }
  uint16_t style() const {
    return GetField<uint16_t>(VT_STYLE, 0);
  }
  uint8_t stance() const {
    return GetField<uint8_t>(VT_STANCE, 0);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  uint8_t healthpercent() const {
    return GetField<uint8_t>(VT_HEALTHPERCENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ATTACKOBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_DEFENDEROBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_WEAPONID, 2) &&
           VerifyField<uint16_t>(verifier, VT_SHIELDID, 2) &&
           VerifyField<uint16_t>(verifier, VT_STYLE, 2) &&
           VerifyField<uint8_t>(verifier, VT_STANCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RESULT, 1) &&
           VerifyField<uint8_t>(verifier, VT_HEALTHPERCENT, 1) &&
           verifier.EndTable();
  }
  SC_CombatAnimation_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CombatAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CombatAnimation> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CombatAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CombatAnimationBuilder {
  typedef SC_CombatAnimation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attackobjectid(uint16_t attackobjectid) {
    fbb_.AddElement<uint16_t>(SC_CombatAnimation::VT_ATTACKOBJECTID, attackobjectid, 0);
  }
  void add_defenderobjectid(uint16_t defenderobjectid) {
    fbb_.AddElement<uint16_t>(SC_CombatAnimation::VT_DEFENDEROBJECTID, defenderobjectid, 0);
  }
  void add_weaponid(uint16_t weaponid) {
    fbb_.AddElement<uint16_t>(SC_CombatAnimation::VT_WEAPONID, weaponid, 0);
  }
  void add_shieldid(uint16_t shieldid) {
    fbb_.AddElement<uint16_t>(SC_CombatAnimation::VT_SHIELDID, shieldid, 0);
  }
  void add_style(uint16_t style) {
    fbb_.AddElement<uint16_t>(SC_CombatAnimation::VT_STYLE, style, 0);
  }
  void add_stance(uint8_t stance) {
    fbb_.AddElement<uint8_t>(SC_CombatAnimation::VT_STANCE, stance, 0);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(SC_CombatAnimation::VT_RESULT, result, 0);
  }
  void add_healthpercent(uint8_t healthpercent) {
    fbb_.AddElement<uint8_t>(SC_CombatAnimation::VT_HEALTHPERCENT, healthpercent, 0);
  }
  explicit SC_CombatAnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CombatAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CombatAnimation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CombatAnimation> CreateSC_CombatAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t attackobjectid = 0,
    uint16_t defenderobjectid = 0,
    uint16_t weaponid = 0,
    uint16_t shieldid = 0,
    uint16_t style = 0,
    uint8_t stance = 0,
    uint8_t result = 0,
    uint8_t healthpercent = 0) {
  SC_CombatAnimationBuilder builder_(_fbb);
  builder_.add_style(style);
  builder_.add_shieldid(shieldid);
  builder_.add_weaponid(weaponid);
  builder_.add_defenderobjectid(defenderobjectid);
  builder_.add_attackobjectid(attackobjectid);
  builder_.add_healthpercent(healthpercent);
  builder_.add_result(result);
  builder_.add_stance(stance);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_CombatAnimation> CreateSC_CombatAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CombatAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_SpellCastAnimation_FBS : public ::flatbuffers::NativeTable {
  typedef SC_SpellCastAnimation TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_SpellCastAnimation_FBS";
  }
  uint16_t objectid = 0;
  uint16_t spellid = 0;
  uint16_t castingtime = 0;
};

struct SC_SpellCastAnimation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SpellCastAnimation_FBS NativeTableType;
  typedef SC_SpellCastAnimationBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_SpellCastAnimation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_SPELLID = 6,
    VT_CASTINGTIME = 8
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t spellid() const {
    return GetField<uint16_t>(VT_SPELLID, 0);
  }
  uint16_t castingtime() const {
    return GetField<uint16_t>(VT_CASTINGTIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_SPELLID, 2) &&
           VerifyField<uint16_t>(verifier, VT_CASTINGTIME, 2) &&
           verifier.EndTable();
  }
  SC_SpellCastAnimation_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_SpellCastAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_SpellCastAnimation> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellCastAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_SpellCastAnimationBuilder {
  typedef SC_SpellCastAnimation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_SpellCastAnimation::VT_OBJECTID, objectid, 0);
  }
  void add_spellid(uint16_t spellid) {
    fbb_.AddElement<uint16_t>(SC_SpellCastAnimation::VT_SPELLID, spellid, 0);
  }
  void add_castingtime(uint16_t castingtime) {
    fbb_.AddElement<uint16_t>(SC_SpellCastAnimation::VT_CASTINGTIME, castingtime, 0);
  }
  explicit SC_SpellCastAnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SpellCastAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SpellCastAnimation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SpellCastAnimation> CreateSC_SpellCastAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t spellid = 0,
    uint16_t castingtime = 0) {
  SC_SpellCastAnimationBuilder builder_(_fbb);
  builder_.add_castingtime(castingtime);
  builder_.add_spellid(spellid);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_SpellCastAnimation> CreateSC_SpellCastAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellCastAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_SpellEffectAnimation_FBS : public ::flatbuffers::NativeTable {
  typedef SC_SpellEffectAnimation TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_SpellEffectAnimation_FBS";
  }
  uint16_t casterobjectid = 0;
  uint16_t spellid = 0;
  uint16_t spelltarget = 0;
  uint16_t bolttime = 0;
  bool nosound = false;
  bool success = false;
};

struct SC_SpellEffectAnimation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SpellEffectAnimation_FBS NativeTableType;
  typedef SC_SpellEffectAnimationBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_SpellEffectAnimation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CASTEROBJECTID = 4,
    VT_SPELLID = 6,
    VT_SPELLTARGET = 8,
    VT_BOLTTIME = 10,
    VT_NOSOUND = 12,
    VT_SUCCESS = 14
  };
  uint16_t casterobjectid() const {
    return GetField<uint16_t>(VT_CASTEROBJECTID, 0);
  }
  uint16_t spellid() const {
    return GetField<uint16_t>(VT_SPELLID, 0);
  }
  uint16_t spelltarget() const {
    return GetField<uint16_t>(VT_SPELLTARGET, 0);
  }
  uint16_t bolttime() const {
    return GetField<uint16_t>(VT_BOLTTIME, 0);
  }
  bool nosound() const {
    return GetField<uint8_t>(VT_NOSOUND, 0) != 0;
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CASTEROBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_SPELLID, 2) &&
           VerifyField<uint16_t>(verifier, VT_SPELLTARGET, 2) &&
           VerifyField<uint16_t>(verifier, VT_BOLTTIME, 2) &&
           VerifyField<uint8_t>(verifier, VT_NOSOUND, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  SC_SpellEffectAnimation_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_SpellEffectAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_SpellEffectAnimation> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellEffectAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_SpellEffectAnimationBuilder {
  typedef SC_SpellEffectAnimation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_casterobjectid(uint16_t casterobjectid) {
    fbb_.AddElement<uint16_t>(SC_SpellEffectAnimation::VT_CASTEROBJECTID, casterobjectid, 0);
  }
  void add_spellid(uint16_t spellid) {
    fbb_.AddElement<uint16_t>(SC_SpellEffectAnimation::VT_SPELLID, spellid, 0);
  }
  void add_spelltarget(uint16_t spelltarget) {
    fbb_.AddElement<uint16_t>(SC_SpellEffectAnimation::VT_SPELLTARGET, spelltarget, 0);
  }
  void add_bolttime(uint16_t bolttime) {
    fbb_.AddElement<uint16_t>(SC_SpellEffectAnimation::VT_BOLTTIME, bolttime, 0);
  }
  void add_nosound(bool nosound) {
    fbb_.AddElement<uint8_t>(SC_SpellEffectAnimation::VT_NOSOUND, static_cast<uint8_t>(nosound), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SC_SpellEffectAnimation::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit SC_SpellEffectAnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SpellEffectAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SpellEffectAnimation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SpellEffectAnimation> CreateSC_SpellEffectAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t casterobjectid = 0,
    uint16_t spellid = 0,
    uint16_t spelltarget = 0,
    uint16_t bolttime = 0,
    bool nosound = false,
    bool success = false) {
  SC_SpellEffectAnimationBuilder builder_(_fbb);
  builder_.add_bolttime(bolttime);
  builder_.add_spelltarget(spelltarget);
  builder_.add_spellid(spellid);
  builder_.add_casterobjectid(casterobjectid);
  builder_.add_success(success);
  builder_.add_nosound(nosound);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_SpellEffectAnimation> CreateSC_SpellEffectAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellEffectAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_EmoteAnimation_FBS : public ::flatbuffers::NativeTable {
  typedef SC_EmoteAnimation TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_EmoteAnimation_FBS";
  }
  uint16_t objectid = 0;
  uint8_t emote = 0;
};

struct SC_EmoteAnimation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_EmoteAnimation_FBS NativeTableType;
  typedef SC_EmoteAnimationBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_EmoteAnimation";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_EMOTE = 6
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint8_t emote() const {
    return GetField<uint8_t>(VT_EMOTE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint8_t>(verifier, VT_EMOTE, 1) &&
           verifier.EndTable();
  }
  SC_EmoteAnimation_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_EmoteAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_EmoteAnimation> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_EmoteAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_EmoteAnimationBuilder {
  typedef SC_EmoteAnimation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_EmoteAnimation::VT_OBJECTID, objectid, 0);
  }
  void add_emote(uint8_t emote) {
    fbb_.AddElement<uint8_t>(SC_EmoteAnimation::VT_EMOTE, emote, 0);
  }
  explicit SC_EmoteAnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_EmoteAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_EmoteAnimation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_EmoteAnimation> CreateSC_EmoteAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint8_t emote = 0) {
  SC_EmoteAnimationBuilder builder_(_fbb);
  builder_.add_objectid(objectid);
  builder_.add_emote(emote);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_EmoteAnimation> CreateSC_EmoteAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_EmoteAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ConcentrationList_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ConcentrationList TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ConcentrationList_FBS";
  }
  std::vector<std::shared_ptr<NetworkMessage::ConEffectData_FBS>> coninfo{};
  SC_ConcentrationList_FBS() = default;
  SC_ConcentrationList_FBS(const SC_ConcentrationList_FBS &o);
  SC_ConcentrationList_FBS(SC_ConcentrationList_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_ConcentrationList_FBS &operator=(SC_ConcentrationList_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_ConcentrationList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ConcentrationList_FBS NativeTableType;
  typedef SC_ConcentrationListBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ConcentrationList";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONINFO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *coninfo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *>(VT_CONINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONINFO) &&
           verifier.VerifyVector(coninfo()) &&
           verifier.VerifyVectorOfTables(coninfo()) &&
           verifier.EndTable();
  }
  SC_ConcentrationList_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ConcentrationList_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ConcentrationList> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ConcentrationListBuilder {
  typedef SC_ConcentrationList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_coninfo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>> coninfo) {
    fbb_.AddOffset(SC_ConcentrationList::VT_CONINFO, coninfo);
  }
  explicit SC_ConcentrationListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ConcentrationList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ConcentrationList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>> coninfo = 0) {
  SC_ConcentrationListBuilder builder_(_fbb);
  builder_.add_coninfo(coninfo);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *coninfo = nullptr) {
  auto coninfo__ = coninfo ? _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>(*coninfo) : 0;
  return NetworkMessage::CreateSC_ConcentrationList(
      _fbb,
      coninfo__);
}

::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_StringMessage_FBS : public ::flatbuffers::NativeTable {
  typedef SC_StringMessage TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_StringMessage_FBS";
  }
  int32_t seesionid = 0;
  NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System;
  NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow;
  std::string message{};
};

struct SC_StringMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_StringMessage_FBS NativeTableType;
  typedef SC_StringMessageBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_StringMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEESIONID = 4,
    VT_CHATTYPE = 6,
    VT_CHATLOC = 8,
    VT_MESSAGE = 10
  };
  int32_t seesionid() const {
    return GetField<int32_t>(VT_SEESIONID, 0);
  }
  NetworkMessage::eChatType chattype() const {
    return static_cast<NetworkMessage::eChatType>(GetField<uint8_t>(VT_CHATTYPE, 0));
  }
  NetworkMessage::eChatLoc chatloc() const {
    return static_cast<NetworkMessage::eChatLoc>(GetField<uint8_t>(VT_CHATLOC, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEESIONID, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHATTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHATLOC, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  SC_StringMessage_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_StringMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_StringMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_StringMessageBuilder {
  typedef SC_StringMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seesionid(int32_t seesionid) {
    fbb_.AddElement<int32_t>(SC_StringMessage::VT_SEESIONID, seesionid, 0);
  }
  void add_chattype(NetworkMessage::eChatType chattype) {
    fbb_.AddElement<uint8_t>(SC_StringMessage::VT_CHATTYPE, static_cast<uint8_t>(chattype), 0);
  }
  void add_chatloc(NetworkMessage::eChatLoc chatloc) {
    fbb_.AddElement<uint8_t>(SC_StringMessage::VT_CHATLOC, static_cast<uint8_t>(chatloc), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SC_StringMessage::VT_MESSAGE, message);
  }
  explicit SC_StringMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_StringMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_StringMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seesionid = 0,
    NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System,
    NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SC_StringMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_seesionid(seesionid);
  builder_.add_chatloc(chatloc);
  builder_.add_chattype(chattype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seesionid = 0,
    NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System,
    NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return NetworkMessage::CreateSC_StringMessage(
      _fbb,
      seesionid,
      chattype,
      chatloc,
      message__);
}

::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_DialogBoxMessage_FBS : public ::flatbuffers::NativeTable {
  typedef SC_DialogBoxMessage TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_DialogBoxMessage_FBS";
  }
  NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning;
  NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok;
  bool autowraptext = false;
  uint16_t data1 = 0;
  uint16_t data2 = 0;
  uint16_t data3 = 0;
  uint16_t data4 = 0;
  std::string message{};
};

struct SC_DialogBoxMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_DialogBoxMessage_FBS NativeTableType;
  typedef SC_DialogBoxMessageBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_DialogBoxMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_TYPE = 6,
    VT_AUTOWRAPTEXT = 8,
    VT_DATA1 = 10,
    VT_DATA2 = 12,
    VT_DATA3 = 14,
    VT_DATA4 = 16,
    VT_MESSAGE = 18
  };
  NetworkMessage::eDialogCode code() const {
    return static_cast<NetworkMessage::eDialogCode>(GetField<uint8_t>(VT_CODE, 0));
  }
  NetworkMessage::eDialogType type() const {
    return static_cast<NetworkMessage::eDialogType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool autowraptext() const {
    return GetField<uint8_t>(VT_AUTOWRAPTEXT, 0) != 0;
  }
  uint16_t data1() const {
    return GetField<uint16_t>(VT_DATA1, 0);
  }
  uint16_t data2() const {
    return GetField<uint16_t>(VT_DATA2, 0);
  }
  uint16_t data3() const {
    return GetField<uint16_t>(VT_DATA3, 0);
  }
  uint16_t data4() const {
    return GetField<uint16_t>(VT_DATA4, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AUTOWRAPTEXT, 1) &&
           VerifyField<uint16_t>(verifier, VT_DATA1, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA2, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA3, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA4, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  SC_DialogBoxMessage_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_DialogBoxMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_DialogBoxMessageBuilder {
  typedef SC_DialogBoxMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(NetworkMessage::eDialogCode code) {
    fbb_.AddElement<uint8_t>(SC_DialogBoxMessage::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_type(NetworkMessage::eDialogType type) {
    fbb_.AddElement<uint8_t>(SC_DialogBoxMessage::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_autowraptext(bool autowraptext) {
    fbb_.AddElement<uint8_t>(SC_DialogBoxMessage::VT_AUTOWRAPTEXT, static_cast<uint8_t>(autowraptext), 0);
  }
  void add_data1(uint16_t data1) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA1, data1, 0);
  }
  void add_data2(uint16_t data2) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA2, data2, 0);
  }
  void add_data3(uint16_t data3) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA3, data3, 0);
  }
  void add_data4(uint16_t data4) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA4, data4, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SC_DialogBoxMessage::VT_MESSAGE, message);
  }
  explicit SC_DialogBoxMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_DialogBoxMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_DialogBoxMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning,
    NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok,
    bool autowraptext = false,
    uint16_t data1 = 0,
    uint16_t data2 = 0,
    uint16_t data3 = 0,
    uint16_t data4 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SC_DialogBoxMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_data4(data4);
  builder_.add_data3(data3);
  builder_.add_data2(data2);
  builder_.add_data1(data1);
  builder_.add_autowraptext(autowraptext);
  builder_.add_type(type);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning,
    NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok,
    bool autowraptext = false,
    uint16_t data1 = 0,
    uint16_t data2 = 0,
    uint16_t data3 = 0,
    uint16_t data4 = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return NetworkMessage::CreateSC_DialogBoxMessage(
      _fbb,
      code,
      type,
      autowraptext,
      data1,
      data2,
      data3,
      data4,
      message__);
}

::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_MaxSpeed_FBS : public ::flatbuffers::NativeTable {
  typedef SC_MaxSpeed TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MaxSpeed_FBS";
  }
  uint16_t speed = 0;
  bool turningdisabled = false;
  uint8_t waterspeed = 0;
};

struct SC_MaxSpeed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_MaxSpeed_FBS NativeTableType;
  typedef SC_MaxSpeedBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MaxSpeed";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_TURNINGDISABLED = 6,
    VT_WATERSPEED = 8
  };
  uint16_t speed() const {
    return GetField<uint16_t>(VT_SPEED, 0);
  }
  bool turningdisabled() const {
    return GetField<uint8_t>(VT_TURNINGDISABLED, 0) != 0;
  }
  uint8_t waterspeed() const {
    return GetField<uint8_t>(VT_WATERSPEED, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SPEED, 2) &&
           VerifyField<uint8_t>(verifier, VT_TURNINGDISABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_WATERSPEED, 1) &&
           verifier.EndTable();
  }
  SC_MaxSpeed_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_MaxSpeed_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_MaxSpeed> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_MaxSpeedBuilder {
  typedef SC_MaxSpeed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed(uint16_t speed) {
    fbb_.AddElement<uint16_t>(SC_MaxSpeed::VT_SPEED, speed, 0);
  }
  void add_turningdisabled(bool turningdisabled) {
    fbb_.AddElement<uint8_t>(SC_MaxSpeed::VT_TURNINGDISABLED, static_cast<uint8_t>(turningdisabled), 0);
  }
  void add_waterspeed(uint8_t waterspeed) {
    fbb_.AddElement<uint8_t>(SC_MaxSpeed::VT_WATERSPEED, waterspeed, 0);
  }
  explicit SC_MaxSpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_MaxSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_MaxSpeed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t speed = 0,
    bool turningdisabled = false,
    uint8_t waterspeed = 0) {
  SC_MaxSpeedBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_waterspeed(waterspeed);
  builder_.add_turningdisabled(turningdisabled);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_Quit_FBS : public ::flatbuffers::NativeTable {
  typedef SC_Quit TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_Quit_FBS";
  }
  bool totalout = false;
  uint8_t level = 0;
};

struct SC_Quit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_Quit_FBS NativeTableType;
  typedef SC_QuitBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_Quit";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALOUT = 4,
    VT_LEVEL = 6
  };
  bool totalout() const {
    return GetField<uint8_t>(VT_TOTALOUT, 0) != 0;
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOTALOUT, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           verifier.EndTable();
  }
  SC_Quit_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_Quit_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_Quit> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_QuitBuilder {
  typedef SC_Quit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_totalout(bool totalout) {
    fbb_.AddElement<uint8_t>(SC_Quit::VT_TOTALOUT, static_cast<uint8_t>(totalout), 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(SC_Quit::VT_LEVEL, level, 0);
  }
  explicit SC_QuitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_Quit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_Quit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_Quit> CreateSC_Quit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool totalout = false,
    uint8_t level = 0) {
  SC_QuitBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_totalout(totalout);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_Quit> CreateSC_Quit(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.pwd == rhs.pwd);
}

inline bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_LoginReq_FBS *CS_LoginReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_LoginReq_FBS>(new CS_LoginReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_LoginReq::UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = pwd(); if (_e) _o->pwd = _e->str(); }
}

inline ::flatbuffers::Offset<CS_LoginReq> CS_LoginReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_LoginReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_LoginReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
  auto _pwd = _o->pwd.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->pwd);
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      _id,
      _pwd);
}


inline bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
  return
      (lhs.gate == rhs.gate);
}

inline bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_WorldJoinReq_FBS *CS_WorldJoinReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_WorldJoinReq_FBS>(new CS_WorldJoinReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_WorldJoinReq::UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gate(); _o->gate = _e; }
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CS_WorldJoinReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_WorldJoinReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_WorldJoinReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gate = _o->gate;
  return NetworkMessage::CreateCS_WorldJoinReq(
      _fbb,
      _gate);
}


inline bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_UpdatePosition_FBS::CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline CS_UpdatePosition_FBS &CS_UpdatePosition_FBS::operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline CS_UpdatePosition_FBS *CS_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_UpdatePosition_FBS>(new CS_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_UpdatePosition::UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CS_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateCS_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
  return
      (lhs.errorcode == rhs.errorcode) &&
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.nickname == rhs.nickname);
}

inline bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_LoginAns_FBS *SC_LoginAns::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_LoginAns_FBS>(new SC_LoginAns_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_LoginAns::UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = errorcode(); _o->errorcode = _e; }
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_LoginAns> SC_LoginAns::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_LoginAns(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_LoginAns_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _errorcode = _o->errorcode;
  auto _sessionid = _o->sessionid;
  auto _nickname = _o->nickname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->nickname);
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      _errorcode,
      _sessionid,
      _nickname);
}


inline bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
  return
      (lhs.chartype == rhs.chartype);
}

inline bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_AccountInfo_FBS *SC_AccountInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_AccountInfo_FBS>(new SC_AccountInfo_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_AccountInfo::UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chartype(); _o->chartype = _e; }
}

inline ::flatbuffers::Offset<SC_AccountInfo> SC_AccountInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_AccountInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_AccountInfo_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chartype = _o->chartype;
  return NetworkMessage::CreateSC_AccountInfo(
      _fbb,
      _chartype);
}


inline bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
  return
      (lhs.zoneid == rhs.zoneid);
}

inline bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_WorldEnterNotify_FBS *SC_WorldEnterNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_WorldEnterNotify_FBS>(new SC_WorldEnterNotify_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_WorldEnterNotify::UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = zoneid(); _o->zoneid = _e; }
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> SC_WorldEnterNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_WorldEnterNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_WorldEnterNotify_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _zoneid = _o->zoneid;
  return NetworkMessage::CreateSC_WorldEnterNotify(
      _fbb,
      _zoneid);
}


inline bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
  return
      ((lhs.player == rhs.player) || (lhs.player && rhs.player && *lhs.player == *rhs.player));
}

inline bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayer_FBS::SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o)
      : player((o.player) ? new NetworkMessage::CreatePlayerInfo_FBS(*o.player) : nullptr) {
}

inline SC_CreatePlayer_FBS &SC_CreatePlayer_FBS::operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayer_FBS *SC_CreatePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayer_FBS>(new SC_CreatePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayer::UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { if(_o->player) { _e->UnPackTo(_o->player.get(), _resolver); } else { _o->player = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->UnPack(_resolver)); } } else if (_o->player) { _o->player.reset(); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayer> SC_CreatePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _o->player ? CreateCreatePlayerInfo(_fbb, _o->player.get(), _rehasher) : 0;
  return NetworkMessage::CreateSC_CreatePlayer(
      _fbb,
      _player);
}


inline bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
  return
      (lhs.player.size() == rhs.player.size() && std::equal(lhs.player.cbegin(), lhs.player.cend(), rhs.player.cbegin(), [](std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &a, std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayers_FBS::SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o) {
  player.reserve(o.player.size());
  for (const auto &player_ : o.player) { player.emplace_back((player_) ? new NetworkMessage::CreatePlayerInfo_FBS(*player_) : nullptr); }
}

inline SC_CreatePlayers_FBS &SC_CreatePlayers_FBS::operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayers_FBS *SC_CreatePlayers::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayers_FBS>(new SC_CreatePlayers_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayers::UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { _o->player.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->player[_i]) { _e->Get(_i)->UnPackTo(_o->player[_i].get(), _resolver); } else { _o->player[_i] = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->player.resize(0); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayers> SC_CreatePlayers::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayers(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayers_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> (_o->player.size(), [](size_t i, _VectorArgs *__va) { return CreateCreatePlayerInfo(*__va->__fbb, __va->__o->player[i].get(), __va->__rehasher); }, &_va );
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      _player);
}


inline bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid);
}

inline bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_RemovePlayer_FBS *SC_RemovePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_RemovePlayer_FBS>(new SC_RemovePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_RemovePlayer::UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
}

inline ::flatbuffers::Offset<SC_RemovePlayer> SC_RemovePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_RemovePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_RemovePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  return NetworkMessage::CreateSC_RemovePlayer(
      _fbb,
      _sessionid);
}


inline bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_UpdatePosition_FBS::SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline SC_UpdatePosition_FBS &SC_UpdatePosition_FBS::operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline SC_UpdatePosition_FBS *SC_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_UpdatePosition_FBS>(new SC_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_UpdatePosition::UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<SC_UpdatePosition> SC_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateSC_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
  return
      (lhs.head == rhs.head) &&
      (lhs.health == rhs.health) &&
      (lhs.state == rhs.state);
}

inline bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_PlayerUpdate_FBS *SC_PlayerUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_PlayerUpdate_FBS>(new SC_PlayerUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_PlayerUpdate::UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = head(); _o->head = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> SC_PlayerUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_PlayerUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_PlayerUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _head = _o->head;
  auto _health = _o->health;
  auto _state = _o->state;
  return NetworkMessage::CreateSC_PlayerUpdate(
      _fbb,
      _head,
      _health,
      _state);
}


inline bool operator==(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs) {
  return
      (lhs.level == rhs.level) &&
      (lhs.maxhealth == rhs.maxhealth) &&
      (lhs.name == rhs.name) &&
      (lhs.classname == rhs.classname) &&
      (lhs.baseclass == rhs.baseclass) &&
      (lhs.lastname == rhs.lastname) &&
      (lhs.guildname == rhs.guildname) &&
      (lhs.language == rhs.language);
}

inline bool operator!=(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_VariousUpdate_FBS *SC_VariousUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_VariousUpdate_FBS>(new SC_VariousUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_VariousUpdate::UnPackTo(SC_VariousUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level(); _o->level = _e; }
  { auto _e = maxhealth(); _o->maxhealth = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = classname(); if (_e) _o->classname = _e->str(); }
  { auto _e = baseclass(); if (_e) _o->baseclass = _e->str(); }
  { auto _e = lastname(); if (_e) _o->lastname = _e->str(); }
  { auto _e = guildname(); if (_e) _o->guildname = _e->str(); }
  { auto _e = language(); if (_e) _o->language = _e->str(); }
}

inline ::flatbuffers::Offset<SC_VariousUpdate> SC_VariousUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_VariousUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_VariousUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level = _o->level;
  auto _maxhealth = _o->maxhealth;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _classname = _o->classname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->classname);
  auto _baseclass = _o->baseclass.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->baseclass);
  auto _lastname = _o->lastname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lastname);
  auto _guildname = _o->guildname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->guildname);
  auto _language = _o->language.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->language);
  return NetworkMessage::CreateSC_VariousUpdate(
      _fbb,
      _level,
      _maxhealth,
      _name,
      _classname,
      _baseclass,
      _lastname,
      _guildname,
      _language);
}


inline bool operator==(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.type == rhs.type);
}

inline bool operator!=(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_RemoveObject_FBS *SC_RemoveObject::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_RemoveObject_FBS>(new SC_RemoveObject_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_RemoveObject::UnPackTo(SC_RemoveObject_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = type(); _o->type = _e; }
}

inline ::flatbuffers::Offset<SC_RemoveObject> SC_RemoveObject::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_RemoveObject(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_RemoveObject_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _type = _o->type;
  return NetworkMessage::CreateSC_RemoveObject(
      _fbb,
      _objectid,
      _type);
}


inline bool operator==(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs) {
  return
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.objectid == rhs.objectid) &&
      (lhs.heading == rhs.heading) &&
      (lhs.model == rhs.model) &&
      (lhs.level == rhs.level) &&
      (lhs.flags == rhs.flags) &&
      (lhs.name == rhs.name) &&
      (lhs.guildname == rhs.guildname) &&
      (lhs.lastname == rhs.lastname);
}

inline bool operator!=(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_PlayerCreate_FBS::SC_PlayerCreate_FBS(const SC_PlayerCreate_FBS &o)
      : position((o.position) ? new NetworkMessage::Vector3Int(*o.position) : nullptr),
        sessionid(o.sessionid),
        objectid(o.objectid),
        heading(o.heading),
        model(o.model),
        level(o.level),
        flags(o.flags),
        name(o.name),
        guildname(o.guildname),
        lastname(o.lastname) {
}

inline SC_PlayerCreate_FBS &SC_PlayerCreate_FBS::operator=(SC_PlayerCreate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(position, o.position);
  std::swap(sessionid, o.sessionid);
  std::swap(objectid, o.objectid);
  std::swap(heading, o.heading);
  std::swap(model, o.model);
  std::swap(level, o.level);
  std::swap(flags, o.flags);
  std::swap(name, o.name);
  std::swap(guildname, o.guildname);
  std::swap(lastname, o.lastname);
  return *this;
}

inline SC_PlayerCreate_FBS *SC_PlayerCreate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_PlayerCreate_FBS>(new SC_PlayerCreate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_PlayerCreate::UnPackTo(SC_PlayerCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = model(); _o->model = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = guildname(); if (_e) _o->guildname = _e->str(); }
  { auto _e = lastname(); if (_e) _o->lastname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_PlayerCreate> SC_PlayerCreate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_PlayerCreate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_PlayerCreate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _sessionid = _o->sessionid;
  auto _objectid = _o->objectid;
  auto _heading = _o->heading;
  auto _model = _o->model;
  auto _level = _o->level;
  auto _flags = _o->flags;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _guildname = _o->guildname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->guildname);
  auto _lastname = _o->lastname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lastname);
  return NetworkMessage::CreateSC_PlayerCreate(
      _fbb,
      _position,
      _sessionid,
      _objectid,
      _heading,
      _model,
      _level,
      _flags,
      _name,
      _guildname,
      _lastname);
}


inline bool operator==(const SC_ModelChange_FBS &lhs, const SC_ModelChange_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.model == rhs.model) &&
      (lhs.newsize == rhs.newsize);
}

inline bool operator!=(const SC_ModelChange_FBS &lhs, const SC_ModelChange_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ModelChange_FBS *SC_ModelChange::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ModelChange_FBS>(new SC_ModelChange_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ModelChange::UnPackTo(SC_ModelChange_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = model(); _o->model = _e; }
  { auto _e = newsize(); _o->newsize = _e; }
}

inline ::flatbuffers::Offset<SC_ModelChange> SC_ModelChange::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ModelChange_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ModelChange(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ModelChange> CreateSC_ModelChange(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ModelChange_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ModelChange_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _model = _o->model;
  auto _newsize = _o->newsize;
  return NetworkMessage::CreateSC_ModelChange(
      _fbb,
      _objectid,
      _model,
      _newsize);
}


inline bool operator==(const SC_ObjectCreate_FBS &lhs, const SC_ObjectCreate_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.heading == rhs.heading) &&
      (lhs.emblem == rhs.emblem) &&
      (lhs.model == rhs.model) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.flags == rhs.flags) &&
      (lhs.name == rhs.name);
}

inline bool operator!=(const SC_ObjectCreate_FBS &lhs, const SC_ObjectCreate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ObjectCreate_FBS::SC_ObjectCreate_FBS(const SC_ObjectCreate_FBS &o)
      : objectid(o.objectid),
        heading(o.heading),
        emblem(o.emblem),
        model(o.model),
        position((o.position) ? new NetworkMessage::Vector3Int(*o.position) : nullptr),
        flags(o.flags),
        name(o.name) {
}

inline SC_ObjectCreate_FBS &SC_ObjectCreate_FBS::operator=(SC_ObjectCreate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(objectid, o.objectid);
  std::swap(heading, o.heading);
  std::swap(emblem, o.emblem);
  std::swap(model, o.model);
  std::swap(position, o.position);
  std::swap(flags, o.flags);
  std::swap(name, o.name);
  return *this;
}

inline SC_ObjectCreate_FBS *SC_ObjectCreate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ObjectCreate_FBS>(new SC_ObjectCreate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ObjectCreate::UnPackTo(SC_ObjectCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = emblem(); _o->emblem = _e; }
  { auto _e = model(); _o->model = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<SC_ObjectCreate> SC_ObjectCreate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ObjectCreate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ObjectCreate> CreateSC_ObjectCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ObjectCreate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _heading = _o->heading;
  auto _emblem = _o->emblem;
  auto _model = _o->model;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _flags = _o->flags;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  return NetworkMessage::CreateSC_ObjectCreate(
      _fbb,
      _objectid,
      _heading,
      _emblem,
      _model,
      _position,
      _flags,
      _name);
}


inline bool operator==(const SC_MovingObjectCreate_FBS &lhs, const SC_MovingObjectCreate_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.heading == rhs.heading) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.model == rhs.model) &&
      (lhs.flags == rhs.flags) &&
      (lhs.emblem == rhs.emblem) &&
      (lhs.name == rhs.name);
}

inline bool operator!=(const SC_MovingObjectCreate_FBS &lhs, const SC_MovingObjectCreate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_MovingObjectCreate_FBS::SC_MovingObjectCreate_FBS(const SC_MovingObjectCreate_FBS &o)
      : objectid(o.objectid),
        heading(o.heading),
        position((o.position) ? new NetworkMessage::Vector3Int(*o.position) : nullptr),
        model(o.model),
        flags(o.flags),
        emblem(o.emblem),
        name(o.name) {
}

inline SC_MovingObjectCreate_FBS &SC_MovingObjectCreate_FBS::operator=(SC_MovingObjectCreate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(objectid, o.objectid);
  std::swap(heading, o.heading);
  std::swap(position, o.position);
  std::swap(model, o.model);
  std::swap(flags, o.flags);
  std::swap(emblem, o.emblem);
  std::swap(name, o.name);
  return *this;
}

inline SC_MovingObjectCreate_FBS *SC_MovingObjectCreate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_MovingObjectCreate_FBS>(new SC_MovingObjectCreate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_MovingObjectCreate::UnPackTo(SC_MovingObjectCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = model(); _o->model = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = emblem(); _o->emblem = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<SC_MovingObjectCreate> SC_MovingObjectCreate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MovingObjectCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_MovingObjectCreate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_MovingObjectCreate> CreateSC_MovingObjectCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MovingObjectCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_MovingObjectCreate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _heading = _o->heading;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _model = _o->model;
  auto _flags = _o->flags;
  auto _emblem = _o->emblem;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  return NetworkMessage::CreateSC_MovingObjectCreate(
      _fbb,
      _objectid,
      _heading,
      _position,
      _model,
      _flags,
      _emblem,
      _name);
}


inline bool operator==(const SC_NPCCreate_FBS &lhs, const SC_NPCCreate_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.heading == rhs.heading) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.speed == rhs.speed) &&
      (lhs.speedz == rhs.speedz) &&
      (lhs.model == rhs.model) &&
      (lhs.size == rhs.size) &&
      (lhs.level == rhs.level) &&
      (lhs.flags == rhs.flags) &&
      (lhs.flags2 == rhs.flags2) &&
      (lhs.flags3 == rhs.flags3) &&
      (lhs.name == rhs.name) &&
      (lhs.guildname == rhs.guildname);
}

inline bool operator!=(const SC_NPCCreate_FBS &lhs, const SC_NPCCreate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_NPCCreate_FBS::SC_NPCCreate_FBS(const SC_NPCCreate_FBS &o)
      : objectid(o.objectid),
        heading(o.heading),
        position((o.position) ? new NetworkMessage::Vector3Int(*o.position) : nullptr),
        speed(o.speed),
        speedz(o.speedz),
        model(o.model),
        size(o.size),
        level(o.level),
        flags(o.flags),
        flags2(o.flags2),
        flags3(o.flags3),
        name(o.name),
        guildname(o.guildname) {
}

inline SC_NPCCreate_FBS &SC_NPCCreate_FBS::operator=(SC_NPCCreate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(objectid, o.objectid);
  std::swap(heading, o.heading);
  std::swap(position, o.position);
  std::swap(speed, o.speed);
  std::swap(speedz, o.speedz);
  std::swap(model, o.model);
  std::swap(size, o.size);
  std::swap(level, o.level);
  std::swap(flags, o.flags);
  std::swap(flags2, o.flags2);
  std::swap(flags3, o.flags3);
  std::swap(name, o.name);
  std::swap(guildname, o.guildname);
  return *this;
}

inline SC_NPCCreate_FBS *SC_NPCCreate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_NPCCreate_FBS>(new SC_NPCCreate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_NPCCreate::UnPackTo(SC_NPCCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = speedz(); _o->speedz = _e; }
  { auto _e = model(); _o->model = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = flags2(); _o->flags2 = _e; }
  { auto _e = flags3(); _o->flags3 = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = guildname(); if (_e) _o->guildname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_NPCCreate> SC_NPCCreate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_NPCCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_NPCCreate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_NPCCreate> CreateSC_NPCCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_NPCCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_NPCCreate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _heading = _o->heading;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _speed = _o->speed;
  auto _speedz = _o->speedz;
  auto _model = _o->model;
  auto _size = _o->size;
  auto _level = _o->level;
  auto _flags = _o->flags;
  auto _flags2 = _o->flags2;
  auto _flags3 = _o->flags3;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _guildname = _o->guildname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->guildname);
  return NetworkMessage::CreateSC_NPCCreate(
      _fbb,
      _objectid,
      _heading,
      _position,
      _speed,
      _speedz,
      _model,
      _size,
      _level,
      _flags,
      _flags2,
      _flags3,
      _name,
      _guildname);
}


inline bool operator==(const SC_CharacterStatusUpdate_FBS &lhs, const SC_CharacterStatusUpdate_FBS &rhs) {
  return
      (lhs.sittingflag == rhs.sittingflag) &&
      (lhs.healthpercent == rhs.healthpercent) &&
      (lhs.manapercent == rhs.manapercent) &&
      (lhs.endurancepercent == rhs.endurancepercent) &&
      (lhs.conpercent == rhs.conpercent) &&
      (lhs.maxmana == rhs.maxmana) &&
      (lhs.maxendurance == rhs.maxendurance) &&
      (lhs.maxconcetration == rhs.maxconcetration) &&
      (lhs.maxhealth == rhs.maxhealth) &&
      (lhs.endurance == rhs.endurance) &&
      (lhs.mana == rhs.mana) &&
      (lhs.concentration == rhs.concentration) &&
      (lhs.health == rhs.health);
}

inline bool operator!=(const SC_CharacterStatusUpdate_FBS &lhs, const SC_CharacterStatusUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CharacterStatusUpdate_FBS *SC_CharacterStatusUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CharacterStatusUpdate_FBS>(new SC_CharacterStatusUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CharacterStatusUpdate::UnPackTo(SC_CharacterStatusUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sittingflag(); _o->sittingflag = _e; }
  { auto _e = healthpercent(); _o->healthpercent = _e; }
  { auto _e = manapercent(); _o->manapercent = _e; }
  { auto _e = endurancepercent(); _o->endurancepercent = _e; }
  { auto _e = conpercent(); _o->conpercent = _e; }
  { auto _e = maxmana(); _o->maxmana = _e; }
  { auto _e = maxendurance(); _o->maxendurance = _e; }
  { auto _e = maxconcetration(); _o->maxconcetration = _e; }
  { auto _e = maxhealth(); _o->maxhealth = _e; }
  { auto _e = endurance(); _o->endurance = _e; }
  { auto _e = mana(); _o->mana = _e; }
  { auto _e = concentration(); _o->concentration = _e; }
  { auto _e = health(); _o->health = _e; }
}

inline ::flatbuffers::Offset<SC_CharacterStatusUpdate> SC_CharacterStatusUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CharacterStatusUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CharacterStatusUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CharacterStatusUpdate> CreateSC_CharacterStatusUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CharacterStatusUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CharacterStatusUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sittingflag = _o->sittingflag;
  auto _healthpercent = _o->healthpercent;
  auto _manapercent = _o->manapercent;
  auto _endurancepercent = _o->endurancepercent;
  auto _conpercent = _o->conpercent;
  auto _maxmana = _o->maxmana;
  auto _maxendurance = _o->maxendurance;
  auto _maxconcetration = _o->maxconcetration;
  auto _maxhealth = _o->maxhealth;
  auto _endurance = _o->endurance;
  auto _mana = _o->mana;
  auto _concentration = _o->concentration;
  auto _health = _o->health;
  return NetworkMessage::CreateSC_CharacterStatusUpdate(
      _fbb,
      _sittingflag,
      _healthpercent,
      _manapercent,
      _endurancepercent,
      _conpercent,
      _maxmana,
      _maxendurance,
      _maxconcetration,
      _maxhealth,
      _endurance,
      _mana,
      _concentration,
      _health);
}


inline bool operator==(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs) {
  return
      (lhs.heading == rhs.heading) &&
      ((lhs.currentzonepos == rhs.currentzonepos) || (lhs.currentzonepos && rhs.currentzonepos && *lhs.currentzonepos == *rhs.currentzonepos)) &&
      ((lhs.targetzonepos == rhs.targetzonepos) || (lhs.targetzonepos && rhs.targetzonepos && *lhs.targetzonepos == *rhs.targetzonepos)) &&
      (lhs.myobjectid == rhs.myobjectid) &&
      (lhs.targetobjectid == rhs.targetobjectid) &&
      (lhs.healthpercent == rhs.healthpercent) &&
      (lhs.flags == rhs.flags) &&
      (lhs.zoneskinid == rhs.zoneskinid) &&
      (lhs.targetzone == rhs.targetzone);
}

inline bool operator!=(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ObjectUpdate_FBS::SC_ObjectUpdate_FBS(const SC_ObjectUpdate_FBS &o)
      : heading(o.heading),
        currentzonepos((o.currentzonepos) ? new NetworkMessage::Vector3Int(*o.currentzonepos) : nullptr),
        targetzonepos((o.targetzonepos) ? new NetworkMessage::Vector3Int(*o.targetzonepos) : nullptr),
        myobjectid(o.myobjectid),
        targetobjectid(o.targetobjectid),
        healthpercent(o.healthpercent),
        flags(o.flags),
        zoneskinid(o.zoneskinid),
        targetzone(o.targetzone) {
}

inline SC_ObjectUpdate_FBS &SC_ObjectUpdate_FBS::operator=(SC_ObjectUpdate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(heading, o.heading);
  std::swap(currentzonepos, o.currentzonepos);
  std::swap(targetzonepos, o.targetzonepos);
  std::swap(myobjectid, o.myobjectid);
  std::swap(targetobjectid, o.targetobjectid);
  std::swap(healthpercent, o.healthpercent);
  std::swap(flags, o.flags);
  std::swap(zoneskinid, o.zoneskinid);
  std::swap(targetzone, o.targetzone);
  return *this;
}

inline SC_ObjectUpdate_FBS *SC_ObjectUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ObjectUpdate_FBS>(new SC_ObjectUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ObjectUpdate::UnPackTo(SC_ObjectUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = currentzonepos(); if (_e) _o->currentzonepos = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = targetzonepos(); if (_e) _o->targetzonepos = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = myobjectid(); _o->myobjectid = _e; }
  { auto _e = targetobjectid(); _o->targetobjectid = _e; }
  { auto _e = healthpercent(); _o->healthpercent = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = zoneskinid(); _o->zoneskinid = _e; }
  { auto _e = targetzone(); _o->targetzone = _e; }
}

inline ::flatbuffers::Offset<SC_ObjectUpdate> SC_ObjectUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ObjectUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ObjectUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heading = _o->heading;
  auto _currentzonepos = _o->currentzonepos ? _o->currentzonepos.get() : nullptr;
  auto _targetzonepos = _o->targetzonepos ? _o->targetzonepos.get() : nullptr;
  auto _myobjectid = _o->myobjectid;
  auto _targetobjectid = _o->targetobjectid;
  auto _healthpercent = _o->healthpercent;
  auto _flags = _o->flags;
  auto _zoneskinid = _o->zoneskinid;
  auto _targetzone = _o->targetzone;
  return NetworkMessage::CreateSC_ObjectUpdate(
      _fbb,
      _heading,
      _currentzonepos,
      _targetzonepos,
      _myobjectid,
      _targetobjectid,
      _healthpercent,
      _flags,
      _zoneskinid,
      _targetzone);
}


inline bool operator==(const SC_CombatAnimation_FBS &lhs, const SC_CombatAnimation_FBS &rhs) {
  return
      (lhs.attackobjectid == rhs.attackobjectid) &&
      (lhs.defenderobjectid == rhs.defenderobjectid) &&
      (lhs.weaponid == rhs.weaponid) &&
      (lhs.shieldid == rhs.shieldid) &&
      (lhs.style == rhs.style) &&
      (lhs.stance == rhs.stance) &&
      (lhs.result == rhs.result) &&
      (lhs.healthpercent == rhs.healthpercent);
}

inline bool operator!=(const SC_CombatAnimation_FBS &lhs, const SC_CombatAnimation_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CombatAnimation_FBS *SC_CombatAnimation::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CombatAnimation_FBS>(new SC_CombatAnimation_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CombatAnimation::UnPackTo(SC_CombatAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attackobjectid(); _o->attackobjectid = _e; }
  { auto _e = defenderobjectid(); _o->defenderobjectid = _e; }
  { auto _e = weaponid(); _o->weaponid = _e; }
  { auto _e = shieldid(); _o->shieldid = _e; }
  { auto _e = style(); _o->style = _e; }
  { auto _e = stance(); _o->stance = _e; }
  { auto _e = result(); _o->result = _e; }
  { auto _e = healthpercent(); _o->healthpercent = _e; }
}

inline ::flatbuffers::Offset<SC_CombatAnimation> SC_CombatAnimation::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CombatAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CombatAnimation(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CombatAnimation> CreateSC_CombatAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CombatAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CombatAnimation_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attackobjectid = _o->attackobjectid;
  auto _defenderobjectid = _o->defenderobjectid;
  auto _weaponid = _o->weaponid;
  auto _shieldid = _o->shieldid;
  auto _style = _o->style;
  auto _stance = _o->stance;
  auto _result = _o->result;
  auto _healthpercent = _o->healthpercent;
  return NetworkMessage::CreateSC_CombatAnimation(
      _fbb,
      _attackobjectid,
      _defenderobjectid,
      _weaponid,
      _shieldid,
      _style,
      _stance,
      _result,
      _healthpercent);
}


inline bool operator==(const SC_SpellCastAnimation_FBS &lhs, const SC_SpellCastAnimation_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.spellid == rhs.spellid) &&
      (lhs.castingtime == rhs.castingtime);
}

inline bool operator!=(const SC_SpellCastAnimation_FBS &lhs, const SC_SpellCastAnimation_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_SpellCastAnimation_FBS *SC_SpellCastAnimation::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_SpellCastAnimation_FBS>(new SC_SpellCastAnimation_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_SpellCastAnimation::UnPackTo(SC_SpellCastAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = spellid(); _o->spellid = _e; }
  { auto _e = castingtime(); _o->castingtime = _e; }
}

inline ::flatbuffers::Offset<SC_SpellCastAnimation> SC_SpellCastAnimation::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellCastAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_SpellCastAnimation(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_SpellCastAnimation> CreateSC_SpellCastAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellCastAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_SpellCastAnimation_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _spellid = _o->spellid;
  auto _castingtime = _o->castingtime;
  return NetworkMessage::CreateSC_SpellCastAnimation(
      _fbb,
      _objectid,
      _spellid,
      _castingtime);
}


inline bool operator==(const SC_SpellEffectAnimation_FBS &lhs, const SC_SpellEffectAnimation_FBS &rhs) {
  return
      (lhs.casterobjectid == rhs.casterobjectid) &&
      (lhs.spellid == rhs.spellid) &&
      (lhs.spelltarget == rhs.spelltarget) &&
      (lhs.bolttime == rhs.bolttime) &&
      (lhs.nosound == rhs.nosound) &&
      (lhs.success == rhs.success);
}

inline bool operator!=(const SC_SpellEffectAnimation_FBS &lhs, const SC_SpellEffectAnimation_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_SpellEffectAnimation_FBS *SC_SpellEffectAnimation::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_SpellEffectAnimation_FBS>(new SC_SpellEffectAnimation_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_SpellEffectAnimation::UnPackTo(SC_SpellEffectAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = casterobjectid(); _o->casterobjectid = _e; }
  { auto _e = spellid(); _o->spellid = _e; }
  { auto _e = spelltarget(); _o->spelltarget = _e; }
  { auto _e = bolttime(); _o->bolttime = _e; }
  { auto _e = nosound(); _o->nosound = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<SC_SpellEffectAnimation> SC_SpellEffectAnimation::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellEffectAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_SpellEffectAnimation(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_SpellEffectAnimation> CreateSC_SpellEffectAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_SpellEffectAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_SpellEffectAnimation_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _casterobjectid = _o->casterobjectid;
  auto _spellid = _o->spellid;
  auto _spelltarget = _o->spelltarget;
  auto _bolttime = _o->bolttime;
  auto _nosound = _o->nosound;
  auto _success = _o->success;
  return NetworkMessage::CreateSC_SpellEffectAnimation(
      _fbb,
      _casterobjectid,
      _spellid,
      _spelltarget,
      _bolttime,
      _nosound,
      _success);
}


inline bool operator==(const SC_EmoteAnimation_FBS &lhs, const SC_EmoteAnimation_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.emote == rhs.emote);
}

inline bool operator!=(const SC_EmoteAnimation_FBS &lhs, const SC_EmoteAnimation_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_EmoteAnimation_FBS *SC_EmoteAnimation::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_EmoteAnimation_FBS>(new SC_EmoteAnimation_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_EmoteAnimation::UnPackTo(SC_EmoteAnimation_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = emote(); _o->emote = _e; }
}

inline ::flatbuffers::Offset<SC_EmoteAnimation> SC_EmoteAnimation::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_EmoteAnimation_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_EmoteAnimation(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_EmoteAnimation> CreateSC_EmoteAnimation(::flatbuffers::FlatBufferBuilder &_fbb, const SC_EmoteAnimation_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_EmoteAnimation_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _emote = _o->emote;
  return NetworkMessage::CreateSC_EmoteAnimation(
      _fbb,
      _objectid,
      _emote);
}


inline bool operator==(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs) {
  return
      (lhs.coninfo.size() == rhs.coninfo.size() && std::equal(lhs.coninfo.cbegin(), lhs.coninfo.cend(), rhs.coninfo.cbegin(), [](std::shared_ptr<NetworkMessage::ConEffectData_FBS> const &a, std::shared_ptr<NetworkMessage::ConEffectData_FBS> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ConcentrationList_FBS::SC_ConcentrationList_FBS(const SC_ConcentrationList_FBS &o) {
  coninfo.reserve(o.coninfo.size());
  for (const auto &coninfo_ : o.coninfo) { coninfo.emplace_back((coninfo_) ? new NetworkMessage::ConEffectData_FBS(*coninfo_) : nullptr); }
}

inline SC_ConcentrationList_FBS &SC_ConcentrationList_FBS::operator=(SC_ConcentrationList_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(coninfo, o.coninfo);
  return *this;
}

inline SC_ConcentrationList_FBS *SC_ConcentrationList::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ConcentrationList_FBS>(new SC_ConcentrationList_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ConcentrationList::UnPackTo(SC_ConcentrationList_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coninfo(); if (_e) { _o->coninfo.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->coninfo[_i]) { _e->Get(_i)->UnPackTo(_o->coninfo[_i].get(), _resolver); } else { _o->coninfo[_i] = std::shared_ptr<NetworkMessage::ConEffectData_FBS>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->coninfo.resize(0); } }
}

inline ::flatbuffers::Offset<SC_ConcentrationList> SC_ConcentrationList::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ConcentrationList(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ConcentrationList_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coninfo = _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> (_o->coninfo.size(), [](size_t i, _VectorArgs *__va) { return CreateConEffectData(*__va->__fbb, __va->__o->coninfo[i].get(), __va->__rehasher); }, &_va );
  return NetworkMessage::CreateSC_ConcentrationList(
      _fbb,
      _coninfo);
}


inline bool operator==(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs) {
  return
      (lhs.seesionid == rhs.seesionid) &&
      (lhs.chattype == rhs.chattype) &&
      (lhs.chatloc == rhs.chatloc) &&
      (lhs.message == rhs.message);
}

inline bool operator!=(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_StringMessage_FBS *SC_StringMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_StringMessage_FBS>(new SC_StringMessage_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_StringMessage::UnPackTo(SC_StringMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seesionid(); _o->seesionid = _e; }
  { auto _e = chattype(); _o->chattype = _e; }
  { auto _e = chatloc(); _o->chatloc = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<SC_StringMessage> SC_StringMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_StringMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_StringMessage_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seesionid = _o->seesionid;
  auto _chattype = _o->chattype;
  auto _chatloc = _o->chatloc;
  auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
  return NetworkMessage::CreateSC_StringMessage(
      _fbb,
      _seesionid,
      _chattype,
      _chatloc,
      _message);
}


inline bool operator==(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs) {
  return
      (lhs.code == rhs.code) &&
      (lhs.type == rhs.type) &&
      (lhs.autowraptext == rhs.autowraptext) &&
      (lhs.data1 == rhs.data1) &&
      (lhs.data2 == rhs.data2) &&
      (lhs.data3 == rhs.data3) &&
      (lhs.data4 == rhs.data4) &&
      (lhs.message == rhs.message);
}

inline bool operator!=(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_DialogBoxMessage_FBS *SC_DialogBoxMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_DialogBoxMessage_FBS>(new SC_DialogBoxMessage_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_DialogBoxMessage::UnPackTo(SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = autowraptext(); _o->autowraptext = _e; }
  { auto _e = data1(); _o->data1 = _e; }
  { auto _e = data2(); _o->data2 = _e; }
  { auto _e = data3(); _o->data3 = _e; }
  { auto _e = data4(); _o->data4 = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> SC_DialogBoxMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_DialogBoxMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_DialogBoxMessage_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _type = _o->type;
  auto _autowraptext = _o->autowraptext;
  auto _data1 = _o->data1;
  auto _data2 = _o->data2;
  auto _data3 = _o->data3;
  auto _data4 = _o->data4;
  auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
  return NetworkMessage::CreateSC_DialogBoxMessage(
      _fbb,
      _code,
      _type,
      _autowraptext,
      _data1,
      _data2,
      _data3,
      _data4,
      _message);
}


inline bool operator==(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs) {
  return
      (lhs.speed == rhs.speed) &&
      (lhs.turningdisabled == rhs.turningdisabled) &&
      (lhs.waterspeed == rhs.waterspeed);
}

inline bool operator!=(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_MaxSpeed_FBS *SC_MaxSpeed::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_MaxSpeed_FBS>(new SC_MaxSpeed_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_MaxSpeed::UnPackTo(SC_MaxSpeed_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = turningdisabled(); _o->turningdisabled = _e; }
  { auto _e = waterspeed(); _o->waterspeed = _e; }
}

inline ::flatbuffers::Offset<SC_MaxSpeed> SC_MaxSpeed::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_MaxSpeed(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_MaxSpeed_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _speed = _o->speed;
  auto _turningdisabled = _o->turningdisabled;
  auto _waterspeed = _o->waterspeed;
  return NetworkMessage::CreateSC_MaxSpeed(
      _fbb,
      _speed,
      _turningdisabled,
      _waterspeed);
}


inline bool operator==(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs) {
  return
      (lhs.totalout == rhs.totalout) &&
      (lhs.level == rhs.level);
}

inline bool operator!=(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_Quit_FBS *SC_Quit::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_Quit_FBS>(new SC_Quit_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_Quit::UnPackTo(SC_Quit_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = totalout(); _o->totalout = _e; }
  { auto _e = level(); _o->level = _e; }
}

inline ::flatbuffers::Offset<SC_Quit> SC_Quit::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_Quit(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_Quit> CreateSC_Quit(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_Quit_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _totalout = _o->totalout;
  auto _level = _o->level;
  return NetworkMessage::CreateSC_Quit(
      _fbb,
      _totalout,
      _level);
}

}  // namespace NetworkMessage

#endif  // FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
