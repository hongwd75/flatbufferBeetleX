// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
#define FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "enumPackets_generated.h"
#include "structs_generated.h"

namespace NetworkMessage {

struct CS_LoginReq;
struct CS_LoginReqBuilder;
struct CS_LoginReq_FBS;

struct CS_WorldJoinReq;
struct CS_WorldJoinReqBuilder;
struct CS_WorldJoinReq_FBS;

struct CS_UpdatePosition;
struct CS_UpdatePositionBuilder;
struct CS_UpdatePosition_FBS;

struct SC_LoginAns;
struct SC_LoginAnsBuilder;
struct SC_LoginAns_FBS;

struct SC_AccountInfo;
struct SC_AccountInfoBuilder;
struct SC_AccountInfo_FBS;

struct SC_WorldEnterNotify;
struct SC_WorldEnterNotifyBuilder;
struct SC_WorldEnterNotify_FBS;

struct SC_CreatePlayer;
struct SC_CreatePlayerBuilder;
struct SC_CreatePlayer_FBS;

struct SC_CreatePlayers;
struct SC_CreatePlayersBuilder;
struct SC_CreatePlayers_FBS;

struct SC_RemovePlayer;
struct SC_RemovePlayerBuilder;
struct SC_RemovePlayer_FBS;

struct SC_UpdatePosition;
struct SC_UpdatePositionBuilder;
struct SC_UpdatePosition_FBS;

struct SC_PlayerUpdate;
struct SC_PlayerUpdateBuilder;
struct SC_PlayerUpdate_FBS;

struct SC_VariousUpdate;
struct SC_VariousUpdateBuilder;
struct SC_VariousUpdate_FBS;

struct SC_RemoveObject;
struct SC_RemoveObjectBuilder;
struct SC_RemoveObject_FBS;

struct SC_PlayerCreate;
struct SC_PlayerCreateBuilder;
struct SC_PlayerCreate_FBS;

struct SC_ObjectUpdate;
struct SC_ObjectUpdateBuilder;
struct SC_ObjectUpdate_FBS;

struct SC_ConcentrationList;
struct SC_ConcentrationListBuilder;
struct SC_ConcentrationList_FBS;

struct SC_StringMessage;
struct SC_StringMessageBuilder;
struct SC_StringMessage_FBS;

struct SC_DialogBoxMessage;
struct SC_DialogBoxMessageBuilder;
struct SC_DialogBoxMessage_FBS;

struct SC_MaxSpeed;
struct SC_MaxSpeedBuilder;
struct SC_MaxSpeed_FBS;

struct SC_Quit;
struct SC_QuitBuilder;
struct SC_Quit_FBS;

bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator==(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs);
bool operator!=(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs);
bool operator==(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs);
bool operator!=(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs);
bool operator==(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs);
bool operator!=(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs);
bool operator==(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs);
bool operator!=(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs);
bool operator==(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs);
bool operator!=(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs);
bool operator==(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs);
bool operator!=(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs);
bool operator==(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs);
bool operator!=(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs);
bool operator==(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs);
bool operator!=(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs);
bool operator==(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs);
bool operator!=(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs);

struct CS_LoginReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_LoginReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq_FBS";
  }
  std::string id{};
  std::string pwd{};
};

struct CS_LoginReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_LoginReq_FBS NativeTableType;
  typedef CS_LoginReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PWD = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *pwd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PWD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.VerifyString(pwd()) &&
           verifier.EndTable();
  }
  CS_LoginReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_LoginReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_LoginReqBuilder {
  typedef CS_LoginReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CS_LoginReq::VT_ID, id);
  }
  void add_pwd(::flatbuffers::Offset<::flatbuffers::String> pwd) {
    fbb_.AddOffset(CS_LoginReq::VT_PWD, pwd);
  }
  explicit CS_LoginReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_LoginReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_LoginReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pwd = 0) {
  CS_LoginReqBuilder builder_(_fbb);
  builder_.add_pwd(pwd);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReqDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *pwd = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto pwd__ = pwd ? _fbb.CreateString(pwd) : 0;
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      id__,
      pwd__);
}

::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_WorldJoinReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_WorldJoinReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq_FBS";
  }
  int32_t gate = 0;
};

struct CS_WorldJoinReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_WorldJoinReq_FBS NativeTableType;
  typedef CS_WorldJoinReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GATE = 4
  };
  int32_t gate() const {
    return GetField<int32_t>(VT_GATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GATE, 4) &&
           verifier.EndTable();
  }
  CS_WorldJoinReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_WorldJoinReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_WorldJoinReqBuilder {
  typedef CS_WorldJoinReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gate(int32_t gate) {
    fbb_.AddElement<int32_t>(CS_WorldJoinReq::VT_GATE, gate, 0);
  }
  explicit CS_WorldJoinReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_WorldJoinReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_WorldJoinReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gate = 0) {
  CS_WorldJoinReqBuilder builder_(_fbb);
  builder_.add_gate(gate);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef CS_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  CS_UpdatePosition_FBS() = default;
  CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o);
  CS_UpdatePosition_FBS(CS_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  CS_UpdatePosition_FBS &operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct CS_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_UpdatePosition_FBS NativeTableType;
  typedef CS_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  CS_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_UpdatePositionBuilder {
  typedef CS_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(CS_UpdatePosition::VT_POSITION, position);
  }
  explicit CS_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  CS_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_LoginAns_FBS : public ::flatbuffers::NativeTable {
  typedef SC_LoginAns TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns_FBS";
  }
  int32_t errorcode = 0;
  int32_t sessionid = 0;
  std::string nickname{};
};

/////////////////////////////////////////////////////////
struct SC_LoginAns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_LoginAns_FBS NativeTableType;
  typedef SC_LoginAnsBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_SESSIONID = 6,
    VT_NICKNAME = 8
  };
  int32_t errorcode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE, 4) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
  SC_LoginAns_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_LoginAns> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_LoginAnsBuilder {
  typedef SC_LoginAns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(int32_t errorcode) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_ERRORCODE, errorcode, 0);
  }
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_SESSIONID, sessionid, 0);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(SC_LoginAns::VT_NICKNAME, nickname);
  }
  explicit SC_LoginAnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_LoginAns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_LoginAns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  SC_LoginAnsBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_sessionid(sessionid);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAnsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    const char *nickname = nullptr) {
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      errorcode,
      sessionid,
      nickname__);
}

::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_AccountInfo_FBS : public ::flatbuffers::NativeTable {
  typedef SC_AccountInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo_FBS";
  }
  int32_t chartype = 0;
};

struct SC_AccountInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_AccountInfo_FBS NativeTableType;
  typedef SC_AccountInfoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARTYPE = 4
  };
  int32_t chartype() const {
    return GetField<int32_t>(VT_CHARTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARTYPE, 4) &&
           verifier.EndTable();
  }
  SC_AccountInfo_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_AccountInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_AccountInfoBuilder {
  typedef SC_AccountInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chartype(int32_t chartype) {
    fbb_.AddElement<int32_t>(SC_AccountInfo::VT_CHARTYPE, chartype, 0);
  }
  explicit SC_AccountInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_AccountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_AccountInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chartype = 0) {
  SC_AccountInfoBuilder builder_(_fbb);
  builder_.add_chartype(chartype);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_WorldEnterNotify_FBS : public ::flatbuffers::NativeTable {
  typedef SC_WorldEnterNotify TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify_FBS";
  }
  int32_t zoneid = 0;
};

struct SC_WorldEnterNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_WorldEnterNotify_FBS NativeTableType;
  typedef SC_WorldEnterNotifyBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZONEID = 4
  };
  int32_t zoneid() const {
    return GetField<int32_t>(VT_ZONEID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZONEID, 4) &&
           verifier.EndTable();
  }
  SC_WorldEnterNotify_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_WorldEnterNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_WorldEnterNotifyBuilder {
  typedef SC_WorldEnterNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_zoneid(int32_t zoneid) {
    fbb_.AddElement<int32_t>(SC_WorldEnterNotify::VT_ZONEID, zoneid, 0);
  }
  explicit SC_WorldEnterNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_WorldEnterNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_WorldEnterNotify>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t zoneid = 0) {
  SC_WorldEnterNotifyBuilder builder_(_fbb);
  builder_.add_zoneid(zoneid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer_FBS";
  }
  std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> player{};
  SC_CreatePlayer_FBS() = default;
  SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o);
  SC_CreatePlayer_FBS(SC_CreatePlayer_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayer_FBS &operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayer_FBS NativeTableType;
  typedef SC_CreatePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const NetworkMessage::CreatePlayerInfo *player() const {
    return GetPointer<const NetworkMessage::CreatePlayerInfo *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayerBuilder {
  typedef SC_CreatePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player) {
    fbb_.AddOffset(SC_CreatePlayer::VT_PLAYER, player);
  }
  explicit SC_CreatePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player = 0) {
  SC_CreatePlayerBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayers_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayers TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers_FBS";
  }
  std::vector<std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>> player{};
  SC_CreatePlayers_FBS() = default;
  SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o);
  SC_CreatePlayers_FBS(SC_CreatePlayers_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayers_FBS &operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayers_FBS NativeTableType;
  typedef SC_CreatePlayersBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyVector(player()) &&
           verifier.VerifyVectorOfTables(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayers_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayers> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayersBuilder {
  typedef SC_CreatePlayers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player) {
    fbb_.AddOffset(SC_CreatePlayers::VT_PLAYER, player);
  }
  explicit SC_CreatePlayersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player = 0) {
  SC_CreatePlayersBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player = nullptr) {
  auto player__ = player ? _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>(*player) : 0;
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      player__);
}

::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_RemovePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_RemovePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer_FBS";
  }
  int32_t sessionid = 0;
};

struct SC_RemovePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_RemovePlayer_FBS NativeTableType;
  typedef SC_RemovePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           verifier.EndTable();
  }
  SC_RemovePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_RemovePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_RemovePlayerBuilder {
  typedef SC_RemovePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_RemovePlayer::VT_SESSIONID, sessionid, 0);
  }
  explicit SC_RemovePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_RemovePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_RemovePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0) {
  SC_RemovePlayerBuilder builder_(_fbb);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef SC_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  SC_UpdatePosition_FBS() = default;
  SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o);
  SC_UpdatePosition_FBS(SC_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_UpdatePosition_FBS &operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_UpdatePosition_FBS NativeTableType;
  typedef SC_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  SC_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_UpdatePositionBuilder {
  typedef SC_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(SC_UpdatePosition::VT_POSITION, position);
  }
  explicit SC_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  SC_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_PlayerUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_PlayerUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate_FBS";
  }
  int32_t head = 0;
  int32_t health = 0;
  int32_t state = 0;
};

struct SC_PlayerUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_PlayerUpdate_FBS NativeTableType;
  typedef SC_PlayerUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEAD = 4,
    VT_HEALTH = 6,
    VT_STATE = 8
  };
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<int32_t>(verifier, VT_HEALTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
  SC_PlayerUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_PlayerUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_PlayerUpdateBuilder {
  typedef SC_PlayerUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEAD, head, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEALTH, health, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_STATE, state, 0);
  }
  explicit SC_PlayerUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_PlayerUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_PlayerUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t head = 0,
    int32_t health = 0,
    int32_t state = 0) {
  SC_PlayerUpdateBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_health(health);
  builder_.add_head(head);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_VariousUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_VariousUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_VariousUpdate_FBS";
  }
  uint16_t level = 0;
  int32_t maxhealth = 0;
  std::string name{};
  std::string classname{};
  std::string baseclass{};
  std::string lastname{};
  std::string guildname{};
  std::string language{};
};

struct SC_VariousUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_VariousUpdate_FBS NativeTableType;
  typedef SC_VariousUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_VariousUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_MAXHEALTH = 6,
    VT_NAME = 8,
    VT_CLASSNAME = 10,
    VT_BASECLASS = 12,
    VT_LASTNAME = 14,
    VT_GUILDNAME = 16,
    VT_LANGUAGE = 18
  };
  uint16_t level() const {
    return GetField<uint16_t>(VT_LEVEL, 0);
  }
  int32_t maxhealth() const {
    return GetField<int32_t>(VT_MAXHEALTH, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *classname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSNAME);
  }
  const ::flatbuffers::String *baseclass() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BASECLASS);
  }
  const ::flatbuffers::String *lastname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTNAME);
  }
  const ::flatbuffers::String *guildname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUILDNAME);
  }
  const ::flatbuffers::String *language() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LANGUAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_LEVEL, 2) &&
           VerifyField<int32_t>(verifier, VT_MAXHEALTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CLASSNAME) &&
           verifier.VerifyString(classname()) &&
           VerifyOffset(verifier, VT_BASECLASS) &&
           verifier.VerifyString(baseclass()) &&
           VerifyOffset(verifier, VT_LASTNAME) &&
           verifier.VerifyString(lastname()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildname()) &&
           VerifyOffset(verifier, VT_LANGUAGE) &&
           verifier.VerifyString(language()) &&
           verifier.EndTable();
  }
  SC_VariousUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_VariousUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_VariousUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_VariousUpdateBuilder {
  typedef SC_VariousUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(uint16_t level) {
    fbb_.AddElement<uint16_t>(SC_VariousUpdate::VT_LEVEL, level, 0);
  }
  void add_maxhealth(int32_t maxhealth) {
    fbb_.AddElement<int32_t>(SC_VariousUpdate::VT_MAXHEALTH, maxhealth, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_VariousUpdate::VT_NAME, name);
  }
  void add_classname(::flatbuffers::Offset<::flatbuffers::String> classname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_CLASSNAME, classname);
  }
  void add_baseclass(::flatbuffers::Offset<::flatbuffers::String> baseclass) {
    fbb_.AddOffset(SC_VariousUpdate::VT_BASECLASS, baseclass);
  }
  void add_lastname(::flatbuffers::Offset<::flatbuffers::String> lastname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_LASTNAME, lastname);
  }
  void add_guildname(::flatbuffers::Offset<::flatbuffers::String> guildname) {
    fbb_.AddOffset(SC_VariousUpdate::VT_GUILDNAME, guildname);
  }
  void add_language(::flatbuffers::Offset<::flatbuffers::String> language) {
    fbb_.AddOffset(SC_VariousUpdate::VT_LANGUAGE, language);
  }
  explicit SC_VariousUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_VariousUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_VariousUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t level = 0,
    int32_t maxhealth = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> baseclass = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guildname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> language = 0) {
  SC_VariousUpdateBuilder builder_(_fbb);
  builder_.add_language(language);
  builder_.add_guildname(guildname);
  builder_.add_lastname(lastname);
  builder_.add_baseclass(baseclass);
  builder_.add_classname(classname);
  builder_.add_name(name);
  builder_.add_maxhealth(maxhealth);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t level = 0,
    int32_t maxhealth = 0,
    const char *name = nullptr,
    const char *classname = nullptr,
    const char *baseclass = nullptr,
    const char *lastname = nullptr,
    const char *guildname = nullptr,
    const char *language = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto classname__ = classname ? _fbb.CreateString(classname) : 0;
  auto baseclass__ = baseclass ? _fbb.CreateString(baseclass) : 0;
  auto lastname__ = lastname ? _fbb.CreateString(lastname) : 0;
  auto guildname__ = guildname ? _fbb.CreateString(guildname) : 0;
  auto language__ = language ? _fbb.CreateString(language) : 0;
  return NetworkMessage::CreateSC_VariousUpdate(
      _fbb,
      level,
      maxhealth,
      name__,
      classname__,
      baseclass__,
      lastname__,
      guildname__,
      language__);
}

::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_RemoveObject_FBS : public ::flatbuffers::NativeTable {
  typedef SC_RemoveObject TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemoveObject_FBS";
  }
  uint16_t objectid = 0;
  uint16_t type = 0;
};

struct SC_RemoveObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_RemoveObject_FBS NativeTableType;
  typedef SC_RemoveObjectBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemoveObject";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_TYPE = 6
  };
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t type() const {
    return GetField<uint16_t>(VT_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_TYPE, 2) &&
           verifier.EndTable();
  }
  SC_RemoveObject_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_RemoveObject_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_RemoveObject> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_RemoveObjectBuilder {
  typedef SC_RemoveObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_RemoveObject::VT_OBJECTID, objectid, 0);
  }
  void add_type(uint16_t type) {
    fbb_.AddElement<uint16_t>(SC_RemoveObject::VT_TYPE, type, 0);
  }
  explicit SC_RemoveObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_RemoveObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_RemoveObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t objectid = 0,
    uint16_t type = 0) {
  SC_RemoveObjectBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_objectid(objectid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_PlayerCreate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_PlayerCreate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerCreate_FBS";
  }
  std::shared_ptr<NetworkMessage::Vector3Int> position{};
  int32_t sessionid = 0;
  uint16_t objectid = 0;
  uint16_t heading = 0;
  uint16_t model = 0;
  uint16_t level = 0;
  uint8_t flags = 0;
  std::string name{};
  std::string guildname{};
  std::string lastname{};
  SC_PlayerCreate_FBS() = default;
  SC_PlayerCreate_FBS(const SC_PlayerCreate_FBS &o);
  SC_PlayerCreate_FBS(SC_PlayerCreate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_PlayerCreate_FBS &operator=(SC_PlayerCreate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_PlayerCreate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_PlayerCreate_FBS NativeTableType;
  typedef SC_PlayerCreateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerCreate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_SESSIONID = 6,
    VT_OBJECTID = 8,
    VT_HEADING = 10,
    VT_MODEL = 12,
    VT_LEVEL = 14,
    VT_FLAGS = 16,
    VT_NAME = 18,
    VT_GUILDNAME = 20,
    VT_LASTNAME = 22
  };
  const NetworkMessage::Vector3Int *position() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_POSITION);
  }
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  uint16_t objectid() const {
    return GetField<uint16_t>(VT_OBJECTID, 0);
  }
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  uint16_t model() const {
    return GetField<uint16_t>(VT_MODEL, 0);
  }
  uint16_t level() const {
    return GetField<uint16_t>(VT_LEVEL, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *guildname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUILDNAME);
  }
  const ::flatbuffers::String *lastname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_POSITION, 4) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<uint16_t>(verifier, VT_MODEL, 2) &&
           VerifyField<uint16_t>(verifier, VT_LEVEL, 2) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_GUILDNAME) &&
           verifier.VerifyString(guildname()) &&
           VerifyOffset(verifier, VT_LASTNAME) &&
           verifier.VerifyString(lastname()) &&
           verifier.EndTable();
  }
  SC_PlayerCreate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_PlayerCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_PlayerCreate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_PlayerCreateBuilder {
  typedef SC_PlayerCreate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const NetworkMessage::Vector3Int *position) {
    fbb_.AddStruct(SC_PlayerCreate::VT_POSITION, position);
  }
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_PlayerCreate::VT_SESSIONID, sessionid, 0);
  }
  void add_objectid(uint16_t objectid) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_OBJECTID, objectid, 0);
  }
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_HEADING, heading, 0);
  }
  void add_model(uint16_t model) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_MODEL, model, 0);
  }
  void add_level(uint16_t level) {
    fbb_.AddElement<uint16_t>(SC_PlayerCreate::VT_LEVEL, level, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(SC_PlayerCreate::VT_FLAGS, flags, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SC_PlayerCreate::VT_NAME, name);
  }
  void add_guildname(::flatbuffers::Offset<::flatbuffers::String> guildname) {
    fbb_.AddOffset(SC_PlayerCreate::VT_GUILDNAME, guildname);
  }
  void add_lastname(::flatbuffers::Offset<::flatbuffers::String> lastname) {
    fbb_.AddOffset(SC_PlayerCreate::VT_LASTNAME, lastname);
  }
  explicit SC_PlayerCreateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_PlayerCreate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_PlayerCreate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t sessionid = 0,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t model = 0,
    uint16_t level = 0,
    uint8_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guildname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastname = 0) {
  SC_PlayerCreateBuilder builder_(_fbb);
  builder_.add_lastname(lastname);
  builder_.add_guildname(guildname);
  builder_.add_name(name);
  builder_.add_sessionid(sessionid);
  builder_.add_position(position);
  builder_.add_level(level);
  builder_.add_model(model);
  builder_.add_heading(heading);
  builder_.add_objectid(objectid);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NetworkMessage::Vector3Int *position = nullptr,
    int32_t sessionid = 0,
    uint16_t objectid = 0,
    uint16_t heading = 0,
    uint16_t model = 0,
    uint16_t level = 0,
    uint8_t flags = 0,
    const char *name = nullptr,
    const char *guildname = nullptr,
    const char *lastname = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto guildname__ = guildname ? _fbb.CreateString(guildname) : 0;
  auto lastname__ = lastname ? _fbb.CreateString(lastname) : 0;
  return NetworkMessage::CreateSC_PlayerCreate(
      _fbb,
      position,
      sessionid,
      objectid,
      heading,
      model,
      level,
      flags,
      name__,
      guildname__,
      lastname__);
}

::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ObjectUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ObjectUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectUpdate_FBS";
  }
  uint16_t heading = 0;
  std::shared_ptr<NetworkMessage::Vector3Int> currentzonepos{};
  std::shared_ptr<NetworkMessage::Vector3Int> targetzonepos{};
  uint16_t myobjectid = 0;
  uint16_t targetobjectid = 0;
  uint8_t healthpercent = 0;
  uint8_t flags = 0;
  uint8_t zoneskinid = 0;
  uint8_t targetzone = 0;
  SC_ObjectUpdate_FBS() = default;
  SC_ObjectUpdate_FBS(const SC_ObjectUpdate_FBS &o);
  SC_ObjectUpdate_FBS(SC_ObjectUpdate_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_ObjectUpdate_FBS &operator=(SC_ObjectUpdate_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_ObjectUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ObjectUpdate_FBS NativeTableType;
  typedef SC_ObjectUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ObjectUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADING = 4,
    VT_CURRENTZONEPOS = 6,
    VT_TARGETZONEPOS = 8,
    VT_MYOBJECTID = 10,
    VT_TARGETOBJECTID = 12,
    VT_HEALTHPERCENT = 14,
    VT_FLAGS = 16,
    VT_ZONESKINID = 18,
    VT_TARGETZONE = 20
  };
  uint16_t heading() const {
    return GetField<uint16_t>(VT_HEADING, 0);
  }
  const NetworkMessage::Vector3Int *currentzonepos() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_CURRENTZONEPOS);
  }
  const NetworkMessage::Vector3Int *targetzonepos() const {
    return GetStruct<const NetworkMessage::Vector3Int *>(VT_TARGETZONEPOS);
  }
  uint16_t myobjectid() const {
    return GetField<uint16_t>(VT_MYOBJECTID, 0);
  }
  uint16_t targetobjectid() const {
    return GetField<uint16_t>(VT_TARGETOBJECTID, 0);
  }
  uint8_t healthpercent() const {
    return GetField<uint8_t>(VT_HEALTHPERCENT, 0);
  }
  uint8_t flags() const {
    return GetField<uint8_t>(VT_FLAGS, 0);
  }
  uint8_t zoneskinid() const {
    return GetField<uint8_t>(VT_ZONESKINID, 0);
  }
  uint8_t targetzone() const {
    return GetField<uint8_t>(VT_TARGETZONE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_HEADING, 2) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_CURRENTZONEPOS, 4) &&
           VerifyField<NetworkMessage::Vector3Int>(verifier, VT_TARGETZONEPOS, 4) &&
           VerifyField<uint16_t>(verifier, VT_MYOBJECTID, 2) &&
           VerifyField<uint16_t>(verifier, VT_TARGETOBJECTID, 2) &&
           VerifyField<uint8_t>(verifier, VT_HEALTHPERCENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZONESKINID, 1) &&
           VerifyField<uint8_t>(verifier, VT_TARGETZONE, 1) &&
           verifier.EndTable();
  }
  SC_ObjectUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ObjectUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ObjectUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ObjectUpdateBuilder {
  typedef SC_ObjectUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heading(uint16_t heading) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_HEADING, heading, 0);
  }
  void add_currentzonepos(const NetworkMessage::Vector3Int *currentzonepos) {
    fbb_.AddStruct(SC_ObjectUpdate::VT_CURRENTZONEPOS, currentzonepos);
  }
  void add_targetzonepos(const NetworkMessage::Vector3Int *targetzonepos) {
    fbb_.AddStruct(SC_ObjectUpdate::VT_TARGETZONEPOS, targetzonepos);
  }
  void add_myobjectid(uint16_t myobjectid) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_MYOBJECTID, myobjectid, 0);
  }
  void add_targetobjectid(uint16_t targetobjectid) {
    fbb_.AddElement<uint16_t>(SC_ObjectUpdate::VT_TARGETOBJECTID, targetobjectid, 0);
  }
  void add_healthpercent(uint8_t healthpercent) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_HEALTHPERCENT, healthpercent, 0);
  }
  void add_flags(uint8_t flags) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_FLAGS, flags, 0);
  }
  void add_zoneskinid(uint8_t zoneskinid) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_ZONESKINID, zoneskinid, 0);
  }
  void add_targetzone(uint8_t targetzone) {
    fbb_.AddElement<uint8_t>(SC_ObjectUpdate::VT_TARGETZONE, targetzone, 0);
  }
  explicit SC_ObjectUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ObjectUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ObjectUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t heading = 0,
    const NetworkMessage::Vector3Int *currentzonepos = nullptr,
    const NetworkMessage::Vector3Int *targetzonepos = nullptr,
    uint16_t myobjectid = 0,
    uint16_t targetobjectid = 0,
    uint8_t healthpercent = 0,
    uint8_t flags = 0,
    uint8_t zoneskinid = 0,
    uint8_t targetzone = 0) {
  SC_ObjectUpdateBuilder builder_(_fbb);
  builder_.add_targetzonepos(targetzonepos);
  builder_.add_currentzonepos(currentzonepos);
  builder_.add_targetobjectid(targetobjectid);
  builder_.add_myobjectid(myobjectid);
  builder_.add_heading(heading);
  builder_.add_targetzone(targetzone);
  builder_.add_zoneskinid(zoneskinid);
  builder_.add_flags(flags);
  builder_.add_healthpercent(healthpercent);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_ConcentrationList_FBS : public ::flatbuffers::NativeTable {
  typedef SC_ConcentrationList TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ConcentrationList_FBS";
  }
  std::vector<std::shared_ptr<NetworkMessage::ConEffectData_FBS>> coninfo{};
  SC_ConcentrationList_FBS() = default;
  SC_ConcentrationList_FBS(const SC_ConcentrationList_FBS &o);
  SC_ConcentrationList_FBS(SC_ConcentrationList_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_ConcentrationList_FBS &operator=(SC_ConcentrationList_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_ConcentrationList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ConcentrationList_FBS NativeTableType;
  typedef SC_ConcentrationListBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_ConcentrationList";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONINFO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *coninfo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *>(VT_CONINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONINFO) &&
           verifier.VerifyVector(coninfo()) &&
           verifier.VerifyVectorOfTables(coninfo()) &&
           verifier.EndTable();
  }
  SC_ConcentrationList_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_ConcentrationList_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_ConcentrationList> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_ConcentrationListBuilder {
  typedef SC_ConcentrationList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_coninfo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>> coninfo) {
    fbb_.AddOffset(SC_ConcentrationList::VT_CONINFO, coninfo);
  }
  explicit SC_ConcentrationListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ConcentrationList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ConcentrationList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>> coninfo = 0) {
  SC_ConcentrationListBuilder builder_(_fbb);
  builder_.add_coninfo(coninfo);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> *coninfo = nullptr) {
  auto coninfo__ = coninfo ? _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::ConEffectData>>(*coninfo) : 0;
  return NetworkMessage::CreateSC_ConcentrationList(
      _fbb,
      coninfo__);
}

::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_StringMessage_FBS : public ::flatbuffers::NativeTable {
  typedef SC_StringMessage TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_StringMessage_FBS";
  }
  int32_t seesionid = 0;
  NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System;
  NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow;
  std::string message{};
};

struct SC_StringMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_StringMessage_FBS NativeTableType;
  typedef SC_StringMessageBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_StringMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEESIONID = 4,
    VT_CHATTYPE = 6,
    VT_CHATLOC = 8,
    VT_MESSAGE = 10
  };
  int32_t seesionid() const {
    return GetField<int32_t>(VT_SEESIONID, 0);
  }
  NetworkMessage::eChatType chattype() const {
    return static_cast<NetworkMessage::eChatType>(GetField<int8_t>(VT_CHATTYPE, 0));
  }
  NetworkMessage::eChatLoc chatloc() const {
    return static_cast<NetworkMessage::eChatLoc>(GetField<int8_t>(VT_CHATLOC, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEESIONID, 4) &&
           VerifyField<int8_t>(verifier, VT_CHATTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_CHATLOC, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  SC_StringMessage_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_StringMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_StringMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_StringMessageBuilder {
  typedef SC_StringMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seesionid(int32_t seesionid) {
    fbb_.AddElement<int32_t>(SC_StringMessage::VT_SEESIONID, seesionid, 0);
  }
  void add_chattype(NetworkMessage::eChatType chattype) {
    fbb_.AddElement<int8_t>(SC_StringMessage::VT_CHATTYPE, static_cast<int8_t>(chattype), 0);
  }
  void add_chatloc(NetworkMessage::eChatLoc chatloc) {
    fbb_.AddElement<int8_t>(SC_StringMessage::VT_CHATLOC, static_cast<int8_t>(chatloc), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SC_StringMessage::VT_MESSAGE, message);
  }
  explicit SC_StringMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_StringMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_StringMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seesionid = 0,
    NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System,
    NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SC_StringMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_seesionid(seesionid);
  builder_.add_chatloc(chatloc);
  builder_.add_chattype(chattype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seesionid = 0,
    NetworkMessage::eChatType chattype = NetworkMessage::eChatType_CT_System,
    NetworkMessage::eChatLoc chatloc = NetworkMessage::eChatLoc_CL_ChatWindow,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return NetworkMessage::CreateSC_StringMessage(
      _fbb,
      seesionid,
      chattype,
      chatloc,
      message__);
}

::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_DialogBoxMessage_FBS : public ::flatbuffers::NativeTable {
  typedef SC_DialogBoxMessage TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_DialogBoxMessage_FBS";
  }
  NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning;
  NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok;
  bool autowraptext = false;
  uint16_t data1 = 0;
  uint16_t data2 = 0;
  uint16_t data3 = 0;
  uint16_t data4 = 0;
  std::string message{};
};

struct SC_DialogBoxMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_DialogBoxMessage_FBS NativeTableType;
  typedef SC_DialogBoxMessageBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_DialogBoxMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_TYPE = 6,
    VT_AUTOWRAPTEXT = 8,
    VT_DATA1 = 10,
    VT_DATA2 = 12,
    VT_DATA3 = 14,
    VT_DATA4 = 16,
    VT_MESSAGE = 18
  };
  NetworkMessage::eDialogCode code() const {
    return static_cast<NetworkMessage::eDialogCode>(GetField<int8_t>(VT_CODE, 0));
  }
  NetworkMessage::eDialogType type() const {
    return static_cast<NetworkMessage::eDialogType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool autowraptext() const {
    return GetField<uint8_t>(VT_AUTOWRAPTEXT, 0) != 0;
  }
  uint16_t data1() const {
    return GetField<uint16_t>(VT_DATA1, 0);
  }
  uint16_t data2() const {
    return GetField<uint16_t>(VT_DATA2, 0);
  }
  uint16_t data3() const {
    return GetField<uint16_t>(VT_DATA3, 0);
  }
  uint16_t data4() const {
    return GetField<uint16_t>(VT_DATA4, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CODE, 1) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AUTOWRAPTEXT, 1) &&
           VerifyField<uint16_t>(verifier, VT_DATA1, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA2, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA3, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA4, 2) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  SC_DialogBoxMessage_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_DialogBoxMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_DialogBoxMessageBuilder {
  typedef SC_DialogBoxMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(NetworkMessage::eDialogCode code) {
    fbb_.AddElement<int8_t>(SC_DialogBoxMessage::VT_CODE, static_cast<int8_t>(code), 0);
  }
  void add_type(NetworkMessage::eDialogType type) {
    fbb_.AddElement<int8_t>(SC_DialogBoxMessage::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_autowraptext(bool autowraptext) {
    fbb_.AddElement<uint8_t>(SC_DialogBoxMessage::VT_AUTOWRAPTEXT, static_cast<uint8_t>(autowraptext), 0);
  }
  void add_data1(uint16_t data1) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA1, data1, 0);
  }
  void add_data2(uint16_t data2) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA2, data2, 0);
  }
  void add_data3(uint16_t data3) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA3, data3, 0);
  }
  void add_data4(uint16_t data4) {
    fbb_.AddElement<uint16_t>(SC_DialogBoxMessage::VT_DATA4, data4, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SC_DialogBoxMessage::VT_MESSAGE, message);
  }
  explicit SC_DialogBoxMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_DialogBoxMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_DialogBoxMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning,
    NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok,
    bool autowraptext = false,
    uint16_t data1 = 0,
    uint16_t data2 = 0,
    uint16_t data3 = 0,
    uint16_t data4 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SC_DialogBoxMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_data4(data4);
  builder_.add_data3(data3);
  builder_.add_data2(data2);
  builder_.add_data1(data1);
  builder_.add_autowraptext(autowraptext);
  builder_.add_type(type);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NetworkMessage::eDialogCode code = NetworkMessage::eDialogCode_SimpleWarning,
    NetworkMessage::eDialogType type = NetworkMessage::eDialogType_Ok,
    bool autowraptext = false,
    uint16_t data1 = 0,
    uint16_t data2 = 0,
    uint16_t data3 = 0,
    uint16_t data4 = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return NetworkMessage::CreateSC_DialogBoxMessage(
      _fbb,
      code,
      type,
      autowraptext,
      data1,
      data2,
      data3,
      data4,
      message__);
}

::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_MaxSpeed_FBS : public ::flatbuffers::NativeTable {
  typedef SC_MaxSpeed TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MaxSpeed_FBS";
  }
  uint16_t speed = 0;
  bool turningdisabled = false;
  uint8_t waterspeed = 0;
};

struct SC_MaxSpeed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_MaxSpeed_FBS NativeTableType;
  typedef SC_MaxSpeedBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_MaxSpeed";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_TURNINGDISABLED = 6,
    VT_WATERSPEED = 8
  };
  uint16_t speed() const {
    return GetField<uint16_t>(VT_SPEED, 0);
  }
  bool turningdisabled() const {
    return GetField<uint8_t>(VT_TURNINGDISABLED, 0) != 0;
  }
  uint8_t waterspeed() const {
    return GetField<uint8_t>(VT_WATERSPEED, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SPEED, 2) &&
           VerifyField<uint8_t>(verifier, VT_TURNINGDISABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_WATERSPEED, 1) &&
           verifier.EndTable();
  }
  SC_MaxSpeed_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_MaxSpeed_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_MaxSpeed> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_MaxSpeedBuilder {
  typedef SC_MaxSpeed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_speed(uint16_t speed) {
    fbb_.AddElement<uint16_t>(SC_MaxSpeed::VT_SPEED, speed, 0);
  }
  void add_turningdisabled(bool turningdisabled) {
    fbb_.AddElement<uint8_t>(SC_MaxSpeed::VT_TURNINGDISABLED, static_cast<uint8_t>(turningdisabled), 0);
  }
  void add_waterspeed(uint8_t waterspeed) {
    fbb_.AddElement<uint8_t>(SC_MaxSpeed::VT_WATERSPEED, waterspeed, 0);
  }
  explicit SC_MaxSpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_MaxSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_MaxSpeed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t speed = 0,
    bool turningdisabled = false,
    uint8_t waterspeed = 0) {
  SC_MaxSpeedBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_waterspeed(waterspeed);
  builder_.add_turningdisabled(turningdisabled);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_Quit_FBS : public ::flatbuffers::NativeTable {
  typedef SC_Quit TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_Quit_FBS";
  }
  bool totalout = false;
  uint8_t level = 0;
};

struct SC_Quit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_Quit_FBS NativeTableType;
  typedef SC_QuitBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_Quit";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALOUT = 4,
    VT_LEVEL = 6
  };
  bool totalout() const {
    return GetField<uint8_t>(VT_TOTALOUT, 0) != 0;
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOTALOUT, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           verifier.EndTable();
  }
  SC_Quit_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_Quit_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_Quit> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_QuitBuilder {
  typedef SC_Quit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_totalout(bool totalout) {
    fbb_.AddElement<uint8_t>(SC_Quit::VT_TOTALOUT, static_cast<uint8_t>(totalout), 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(SC_Quit::VT_LEVEL, level, 0);
  }
  explicit SC_QuitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_Quit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_Quit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_Quit> CreateSC_Quit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool totalout = false,
    uint8_t level = 0) {
  SC_QuitBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_totalout(totalout);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_Quit> CreateSC_Quit(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.pwd == rhs.pwd);
}

inline bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_LoginReq_FBS *CS_LoginReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_LoginReq_FBS>(new CS_LoginReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_LoginReq::UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = pwd(); if (_e) _o->pwd = _e->str(); }
}

inline ::flatbuffers::Offset<CS_LoginReq> CS_LoginReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_LoginReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_LoginReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
  auto _pwd = _o->pwd.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->pwd);
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      _id,
      _pwd);
}


inline bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
  return
      (lhs.gate == rhs.gate);
}

inline bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_WorldJoinReq_FBS *CS_WorldJoinReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_WorldJoinReq_FBS>(new CS_WorldJoinReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_WorldJoinReq::UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gate(); _o->gate = _e; }
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CS_WorldJoinReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_WorldJoinReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_WorldJoinReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gate = _o->gate;
  return NetworkMessage::CreateCS_WorldJoinReq(
      _fbb,
      _gate);
}


inline bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_UpdatePosition_FBS::CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline CS_UpdatePosition_FBS &CS_UpdatePosition_FBS::operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline CS_UpdatePosition_FBS *CS_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_UpdatePosition_FBS>(new CS_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_UpdatePosition::UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CS_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateCS_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
  return
      (lhs.errorcode == rhs.errorcode) &&
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.nickname == rhs.nickname);
}

inline bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_LoginAns_FBS *SC_LoginAns::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_LoginAns_FBS>(new SC_LoginAns_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_LoginAns::UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = errorcode(); _o->errorcode = _e; }
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_LoginAns> SC_LoginAns::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_LoginAns(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_LoginAns_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _errorcode = _o->errorcode;
  auto _sessionid = _o->sessionid;
  auto _nickname = _o->nickname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->nickname);
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      _errorcode,
      _sessionid,
      _nickname);
}


inline bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
  return
      (lhs.chartype == rhs.chartype);
}

inline bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_AccountInfo_FBS *SC_AccountInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_AccountInfo_FBS>(new SC_AccountInfo_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_AccountInfo::UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chartype(); _o->chartype = _e; }
}

inline ::flatbuffers::Offset<SC_AccountInfo> SC_AccountInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_AccountInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_AccountInfo_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chartype = _o->chartype;
  return NetworkMessage::CreateSC_AccountInfo(
      _fbb,
      _chartype);
}


inline bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
  return
      (lhs.zoneid == rhs.zoneid);
}

inline bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_WorldEnterNotify_FBS *SC_WorldEnterNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_WorldEnterNotify_FBS>(new SC_WorldEnterNotify_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_WorldEnterNotify::UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = zoneid(); _o->zoneid = _e; }
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> SC_WorldEnterNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_WorldEnterNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_WorldEnterNotify_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _zoneid = _o->zoneid;
  return NetworkMessage::CreateSC_WorldEnterNotify(
      _fbb,
      _zoneid);
}


inline bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
  return
      ((lhs.player == rhs.player) || (lhs.player && rhs.player && *lhs.player == *rhs.player));
}

inline bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayer_FBS::SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o)
      : player((o.player) ? new NetworkMessage::CreatePlayerInfo_FBS(*o.player) : nullptr) {
}

inline SC_CreatePlayer_FBS &SC_CreatePlayer_FBS::operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayer_FBS *SC_CreatePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayer_FBS>(new SC_CreatePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayer::UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { if(_o->player) { _e->UnPackTo(_o->player.get(), _resolver); } else { _o->player = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->UnPack(_resolver)); } } else if (_o->player) { _o->player.reset(); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayer> SC_CreatePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _o->player ? CreateCreatePlayerInfo(_fbb, _o->player.get(), _rehasher) : 0;
  return NetworkMessage::CreateSC_CreatePlayer(
      _fbb,
      _player);
}


inline bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
  return
      (lhs.player.size() == rhs.player.size() && std::equal(lhs.player.cbegin(), lhs.player.cend(), rhs.player.cbegin(), [](std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &a, std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayers_FBS::SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o) {
  player.reserve(o.player.size());
  for (const auto &player_ : o.player) { player.emplace_back((player_) ? new NetworkMessage::CreatePlayerInfo_FBS(*player_) : nullptr); }
}

inline SC_CreatePlayers_FBS &SC_CreatePlayers_FBS::operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayers_FBS *SC_CreatePlayers::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayers_FBS>(new SC_CreatePlayers_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayers::UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { _o->player.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->player[_i]) { _e->Get(_i)->UnPackTo(_o->player[_i].get(), _resolver); } else { _o->player[_i] = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->player.resize(0); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayers> SC_CreatePlayers::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayers(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayers_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> (_o->player.size(), [](size_t i, _VectorArgs *__va) { return CreateCreatePlayerInfo(*__va->__fbb, __va->__o->player[i].get(), __va->__rehasher); }, &_va );
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      _player);
}


inline bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid);
}

inline bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_RemovePlayer_FBS *SC_RemovePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_RemovePlayer_FBS>(new SC_RemovePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_RemovePlayer::UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
}

inline ::flatbuffers::Offset<SC_RemovePlayer> SC_RemovePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_RemovePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_RemovePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  return NetworkMessage::CreateSC_RemovePlayer(
      _fbb,
      _sessionid);
}


inline bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_UpdatePosition_FBS::SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline SC_UpdatePosition_FBS &SC_UpdatePosition_FBS::operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline SC_UpdatePosition_FBS *SC_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_UpdatePosition_FBS>(new SC_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_UpdatePosition::UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<SC_UpdatePosition> SC_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateSC_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
  return
      (lhs.head == rhs.head) &&
      (lhs.health == rhs.health) &&
      (lhs.state == rhs.state);
}

inline bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_PlayerUpdate_FBS *SC_PlayerUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_PlayerUpdate_FBS>(new SC_PlayerUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_PlayerUpdate::UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = head(); _o->head = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> SC_PlayerUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_PlayerUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_PlayerUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _head = _o->head;
  auto _health = _o->health;
  auto _state = _o->state;
  return NetworkMessage::CreateSC_PlayerUpdate(
      _fbb,
      _head,
      _health,
      _state);
}


inline bool operator==(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs) {
  return
      (lhs.level == rhs.level) &&
      (lhs.maxhealth == rhs.maxhealth) &&
      (lhs.name == rhs.name) &&
      (lhs.classname == rhs.classname) &&
      (lhs.baseclass == rhs.baseclass) &&
      (lhs.lastname == rhs.lastname) &&
      (lhs.guildname == rhs.guildname) &&
      (lhs.language == rhs.language);
}

inline bool operator!=(const SC_VariousUpdate_FBS &lhs, const SC_VariousUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_VariousUpdate_FBS *SC_VariousUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_VariousUpdate_FBS>(new SC_VariousUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_VariousUpdate::UnPackTo(SC_VariousUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level(); _o->level = _e; }
  { auto _e = maxhealth(); _o->maxhealth = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = classname(); if (_e) _o->classname = _e->str(); }
  { auto _e = baseclass(); if (_e) _o->baseclass = _e->str(); }
  { auto _e = lastname(); if (_e) _o->lastname = _e->str(); }
  { auto _e = guildname(); if (_e) _o->guildname = _e->str(); }
  { auto _e = language(); if (_e) _o->language = _e->str(); }
}

inline ::flatbuffers::Offset<SC_VariousUpdate> SC_VariousUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_VariousUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_VariousUpdate> CreateSC_VariousUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_VariousUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_VariousUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level = _o->level;
  auto _maxhealth = _o->maxhealth;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _classname = _o->classname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->classname);
  auto _baseclass = _o->baseclass.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->baseclass);
  auto _lastname = _o->lastname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lastname);
  auto _guildname = _o->guildname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->guildname);
  auto _language = _o->language.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->language);
  return NetworkMessage::CreateSC_VariousUpdate(
      _fbb,
      _level,
      _maxhealth,
      _name,
      _classname,
      _baseclass,
      _lastname,
      _guildname,
      _language);
}


inline bool operator==(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs) {
  return
      (lhs.objectid == rhs.objectid) &&
      (lhs.type == rhs.type);
}

inline bool operator!=(const SC_RemoveObject_FBS &lhs, const SC_RemoveObject_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_RemoveObject_FBS *SC_RemoveObject::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_RemoveObject_FBS>(new SC_RemoveObject_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_RemoveObject::UnPackTo(SC_RemoveObject_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = type(); _o->type = _e; }
}

inline ::flatbuffers::Offset<SC_RemoveObject> SC_RemoveObject::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_RemoveObject(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_RemoveObject> CreateSC_RemoveObject(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemoveObject_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_RemoveObject_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _objectid = _o->objectid;
  auto _type = _o->type;
  return NetworkMessage::CreateSC_RemoveObject(
      _fbb,
      _objectid,
      _type);
}


inline bool operator==(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs) {
  return
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.objectid == rhs.objectid) &&
      (lhs.heading == rhs.heading) &&
      (lhs.model == rhs.model) &&
      (lhs.level == rhs.level) &&
      (lhs.flags == rhs.flags) &&
      (lhs.name == rhs.name) &&
      (lhs.guildname == rhs.guildname) &&
      (lhs.lastname == rhs.lastname);
}

inline bool operator!=(const SC_PlayerCreate_FBS &lhs, const SC_PlayerCreate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_PlayerCreate_FBS::SC_PlayerCreate_FBS(const SC_PlayerCreate_FBS &o)
      : position((o.position) ? new NetworkMessage::Vector3Int(*o.position) : nullptr),
        sessionid(o.sessionid),
        objectid(o.objectid),
        heading(o.heading),
        model(o.model),
        level(o.level),
        flags(o.flags),
        name(o.name),
        guildname(o.guildname),
        lastname(o.lastname) {
}

inline SC_PlayerCreate_FBS &SC_PlayerCreate_FBS::operator=(SC_PlayerCreate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(position, o.position);
  std::swap(sessionid, o.sessionid);
  std::swap(objectid, o.objectid);
  std::swap(heading, o.heading);
  std::swap(model, o.model);
  std::swap(level, o.level);
  std::swap(flags, o.flags);
  std::swap(name, o.name);
  std::swap(guildname, o.guildname);
  std::swap(lastname, o.lastname);
  return *this;
}

inline SC_PlayerCreate_FBS *SC_PlayerCreate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_PlayerCreate_FBS>(new SC_PlayerCreate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_PlayerCreate::UnPackTo(SC_PlayerCreate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = objectid(); _o->objectid = _e; }
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = model(); _o->model = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = guildname(); if (_e) _o->guildname = _e->str(); }
  { auto _e = lastname(); if (_e) _o->lastname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_PlayerCreate> SC_PlayerCreate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_PlayerCreate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_PlayerCreate> CreateSC_PlayerCreate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerCreate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_PlayerCreate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _sessionid = _o->sessionid;
  auto _objectid = _o->objectid;
  auto _heading = _o->heading;
  auto _model = _o->model;
  auto _level = _o->level;
  auto _flags = _o->flags;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _guildname = _o->guildname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->guildname);
  auto _lastname = _o->lastname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->lastname);
  return NetworkMessage::CreateSC_PlayerCreate(
      _fbb,
      _position,
      _sessionid,
      _objectid,
      _heading,
      _model,
      _level,
      _flags,
      _name,
      _guildname,
      _lastname);
}


inline bool operator==(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs) {
  return
      (lhs.heading == rhs.heading) &&
      ((lhs.currentzonepos == rhs.currentzonepos) || (lhs.currentzonepos && rhs.currentzonepos && *lhs.currentzonepos == *rhs.currentzonepos)) &&
      ((lhs.targetzonepos == rhs.targetzonepos) || (lhs.targetzonepos && rhs.targetzonepos && *lhs.targetzonepos == *rhs.targetzonepos)) &&
      (lhs.myobjectid == rhs.myobjectid) &&
      (lhs.targetobjectid == rhs.targetobjectid) &&
      (lhs.healthpercent == rhs.healthpercent) &&
      (lhs.flags == rhs.flags) &&
      (lhs.zoneskinid == rhs.zoneskinid) &&
      (lhs.targetzone == rhs.targetzone);
}

inline bool operator!=(const SC_ObjectUpdate_FBS &lhs, const SC_ObjectUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ObjectUpdate_FBS::SC_ObjectUpdate_FBS(const SC_ObjectUpdate_FBS &o)
      : heading(o.heading),
        currentzonepos((o.currentzonepos) ? new NetworkMessage::Vector3Int(*o.currentzonepos) : nullptr),
        targetzonepos((o.targetzonepos) ? new NetworkMessage::Vector3Int(*o.targetzonepos) : nullptr),
        myobjectid(o.myobjectid),
        targetobjectid(o.targetobjectid),
        healthpercent(o.healthpercent),
        flags(o.flags),
        zoneskinid(o.zoneskinid),
        targetzone(o.targetzone) {
}

inline SC_ObjectUpdate_FBS &SC_ObjectUpdate_FBS::operator=(SC_ObjectUpdate_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(heading, o.heading);
  std::swap(currentzonepos, o.currentzonepos);
  std::swap(targetzonepos, o.targetzonepos);
  std::swap(myobjectid, o.myobjectid);
  std::swap(targetobjectid, o.targetobjectid);
  std::swap(healthpercent, o.healthpercent);
  std::swap(flags, o.flags);
  std::swap(zoneskinid, o.zoneskinid);
  std::swap(targetzone, o.targetzone);
  return *this;
}

inline SC_ObjectUpdate_FBS *SC_ObjectUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ObjectUpdate_FBS>(new SC_ObjectUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ObjectUpdate::UnPackTo(SC_ObjectUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heading(); _o->heading = _e; }
  { auto _e = currentzonepos(); if (_e) _o->currentzonepos = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = targetzonepos(); if (_e) _o->targetzonepos = std::shared_ptr<NetworkMessage::Vector3Int>(new NetworkMessage::Vector3Int(*_e)); }
  { auto _e = myobjectid(); _o->myobjectid = _e; }
  { auto _e = targetobjectid(); _o->targetobjectid = _e; }
  { auto _e = healthpercent(); _o->healthpercent = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = zoneskinid(); _o->zoneskinid = _e; }
  { auto _e = targetzone(); _o->targetzone = _e; }
}

inline ::flatbuffers::Offset<SC_ObjectUpdate> SC_ObjectUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ObjectUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ObjectUpdate> CreateSC_ObjectUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ObjectUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ObjectUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heading = _o->heading;
  auto _currentzonepos = _o->currentzonepos ? _o->currentzonepos.get() : nullptr;
  auto _targetzonepos = _o->targetzonepos ? _o->targetzonepos.get() : nullptr;
  auto _myobjectid = _o->myobjectid;
  auto _targetobjectid = _o->targetobjectid;
  auto _healthpercent = _o->healthpercent;
  auto _flags = _o->flags;
  auto _zoneskinid = _o->zoneskinid;
  auto _targetzone = _o->targetzone;
  return NetworkMessage::CreateSC_ObjectUpdate(
      _fbb,
      _heading,
      _currentzonepos,
      _targetzonepos,
      _myobjectid,
      _targetobjectid,
      _healthpercent,
      _flags,
      _zoneskinid,
      _targetzone);
}


inline bool operator==(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs) {
  return
      (lhs.coninfo.size() == rhs.coninfo.size() && std::equal(lhs.coninfo.cbegin(), lhs.coninfo.cend(), rhs.coninfo.cbegin(), [](std::shared_ptr<NetworkMessage::ConEffectData_FBS> const &a, std::shared_ptr<NetworkMessage::ConEffectData_FBS> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const SC_ConcentrationList_FBS &lhs, const SC_ConcentrationList_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_ConcentrationList_FBS::SC_ConcentrationList_FBS(const SC_ConcentrationList_FBS &o) {
  coninfo.reserve(o.coninfo.size());
  for (const auto &coninfo_ : o.coninfo) { coninfo.emplace_back((coninfo_) ? new NetworkMessage::ConEffectData_FBS(*coninfo_) : nullptr); }
}

inline SC_ConcentrationList_FBS &SC_ConcentrationList_FBS::operator=(SC_ConcentrationList_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(coninfo, o.coninfo);
  return *this;
}

inline SC_ConcentrationList_FBS *SC_ConcentrationList::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_ConcentrationList_FBS>(new SC_ConcentrationList_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_ConcentrationList::UnPackTo(SC_ConcentrationList_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coninfo(); if (_e) { _o->coninfo.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->coninfo[_i]) { _e->Get(_i)->UnPackTo(_o->coninfo[_i].get(), _resolver); } else { _o->coninfo[_i] = std::shared_ptr<NetworkMessage::ConEffectData_FBS>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->coninfo.resize(0); } }
}

inline ::flatbuffers::Offset<SC_ConcentrationList> SC_ConcentrationList::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_ConcentrationList(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_ConcentrationList> CreateSC_ConcentrationList(::flatbuffers::FlatBufferBuilder &_fbb, const SC_ConcentrationList_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_ConcentrationList_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coninfo = _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::ConEffectData>> (_o->coninfo.size(), [](size_t i, _VectorArgs *__va) { return CreateConEffectData(*__va->__fbb, __va->__o->coninfo[i].get(), __va->__rehasher); }, &_va );
  return NetworkMessage::CreateSC_ConcentrationList(
      _fbb,
      _coninfo);
}


inline bool operator==(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs) {
  return
      (lhs.seesionid == rhs.seesionid) &&
      (lhs.chattype == rhs.chattype) &&
      (lhs.chatloc == rhs.chatloc) &&
      (lhs.message == rhs.message);
}

inline bool operator!=(const SC_StringMessage_FBS &lhs, const SC_StringMessage_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_StringMessage_FBS *SC_StringMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_StringMessage_FBS>(new SC_StringMessage_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_StringMessage::UnPackTo(SC_StringMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seesionid(); _o->seesionid = _e; }
  { auto _e = chattype(); _o->chattype = _e; }
  { auto _e = chatloc(); _o->chatloc = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<SC_StringMessage> SC_StringMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_StringMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_StringMessage> CreateSC_StringMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_StringMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_StringMessage_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seesionid = _o->seesionid;
  auto _chattype = _o->chattype;
  auto _chatloc = _o->chatloc;
  auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
  return NetworkMessage::CreateSC_StringMessage(
      _fbb,
      _seesionid,
      _chattype,
      _chatloc,
      _message);
}


inline bool operator==(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs) {
  return
      (lhs.code == rhs.code) &&
      (lhs.type == rhs.type) &&
      (lhs.autowraptext == rhs.autowraptext) &&
      (lhs.data1 == rhs.data1) &&
      (lhs.data2 == rhs.data2) &&
      (lhs.data3 == rhs.data3) &&
      (lhs.data4 == rhs.data4) &&
      (lhs.message == rhs.message);
}

inline bool operator!=(const SC_DialogBoxMessage_FBS &lhs, const SC_DialogBoxMessage_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_DialogBoxMessage_FBS *SC_DialogBoxMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_DialogBoxMessage_FBS>(new SC_DialogBoxMessage_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_DialogBoxMessage::UnPackTo(SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = autowraptext(); _o->autowraptext = _e; }
  { auto _e = data1(); _o->data1 = _e; }
  { auto _e = data2(); _o->data2 = _e; }
  { auto _e = data3(); _o->data3 = _e; }
  { auto _e = data4(); _o->data4 = _e; }
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> SC_DialogBoxMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_DialogBoxMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_DialogBoxMessage> CreateSC_DialogBoxMessage(::flatbuffers::FlatBufferBuilder &_fbb, const SC_DialogBoxMessage_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_DialogBoxMessage_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _type = _o->type;
  auto _autowraptext = _o->autowraptext;
  auto _data1 = _o->data1;
  auto _data2 = _o->data2;
  auto _data3 = _o->data3;
  auto _data4 = _o->data4;
  auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
  return NetworkMessage::CreateSC_DialogBoxMessage(
      _fbb,
      _code,
      _type,
      _autowraptext,
      _data1,
      _data2,
      _data3,
      _data4,
      _message);
}


inline bool operator==(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs) {
  return
      (lhs.speed == rhs.speed) &&
      (lhs.turningdisabled == rhs.turningdisabled) &&
      (lhs.waterspeed == rhs.waterspeed);
}

inline bool operator!=(const SC_MaxSpeed_FBS &lhs, const SC_MaxSpeed_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_MaxSpeed_FBS *SC_MaxSpeed::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_MaxSpeed_FBS>(new SC_MaxSpeed_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_MaxSpeed::UnPackTo(SC_MaxSpeed_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = turningdisabled(); _o->turningdisabled = _e; }
  { auto _e = waterspeed(); _o->waterspeed = _e; }
}

inline ::flatbuffers::Offset<SC_MaxSpeed> SC_MaxSpeed::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_MaxSpeed(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_MaxSpeed> CreateSC_MaxSpeed(::flatbuffers::FlatBufferBuilder &_fbb, const SC_MaxSpeed_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_MaxSpeed_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _speed = _o->speed;
  auto _turningdisabled = _o->turningdisabled;
  auto _waterspeed = _o->waterspeed;
  return NetworkMessage::CreateSC_MaxSpeed(
      _fbb,
      _speed,
      _turningdisabled,
      _waterspeed);
}


inline bool operator==(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs) {
  return
      (lhs.totalout == rhs.totalout) &&
      (lhs.level == rhs.level);
}

inline bool operator!=(const SC_Quit_FBS &lhs, const SC_Quit_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_Quit_FBS *SC_Quit::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_Quit_FBS>(new SC_Quit_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_Quit::UnPackTo(SC_Quit_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = totalout(); _o->totalout = _e; }
  { auto _e = level(); _o->level = _e; }
}

inline ::flatbuffers::Offset<SC_Quit> SC_Quit::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_Quit(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_Quit> CreateSC_Quit(::flatbuffers::FlatBufferBuilder &_fbb, const SC_Quit_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_Quit_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _totalout = _o->totalout;
  auto _level = _o->level;
  return NetworkMessage::CreateSC_Quit(
      _fbb,
      _totalout,
      _level);
}

}  // namespace NetworkMessage

#endif  // FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
